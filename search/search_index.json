{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About BracketHighlighter Overview BracketHighlighter matches a variety of brackets such as: [] , () , {} , \"\" , '' , <tag></tag> , and even custom brackets. This was originally forked from pyparadigm's SublimeBrackets and SublimeTagmatcher (both are no longer available). I forked his repositories to fix a number issues I add some features I had wanted. I also wanted to improve the efficiency of the matching. Moving forward, I have thrown away all of the code and have completely rewritten the entire code base to allow for more flexibility, faster matching, and a more feature rich experience. Feature List Customizable to highlight almost any bracket. Customizable bracket highlight style. High visibility bracket highlight mode. Selectively disable or enable specific matching of tags, brackets, or quotes. Selectively use an allowlist or blocklist for matching specific tags, brackets, or quotes based on language. When bound to a shortcut, allow options to show line count and char count between match in the status bar. Highlight basic brackets within strings. Works with multi-select. Configurable custom gutter icons. Toggle bracket escape mode for string brackets (regex|string). Bracket plugins that can jump between bracket ends, select content, etc. Credits pyparadigm: for his original efforts with SublimeBrackets and SublimeTagmatcher which originally BracketHighlighter was built off of and the inspiration for this project. BoundInCode: for his Tag icon.","title":"About BracketHighlighter"},{"location":"#about-brackethighlighter","text":"","title":"About BracketHighlighter"},{"location":"#overview","text":"BracketHighlighter matches a variety of brackets such as: [] , () , {} , \"\" , '' , <tag></tag> , and even custom brackets. This was originally forked from pyparadigm's SublimeBrackets and SublimeTagmatcher (both are no longer available). I forked his repositories to fix a number issues I add some features I had wanted. I also wanted to improve the efficiency of the matching. Moving forward, I have thrown away all of the code and have completely rewritten the entire code base to allow for more flexibility, faster matching, and a more feature rich experience.","title":"Overview"},{"location":"#feature-list","text":"Customizable to highlight almost any bracket. Customizable bracket highlight style. High visibility bracket highlight mode. Selectively disable or enable specific matching of tags, brackets, or quotes. Selectively use an allowlist or blocklist for matching specific tags, brackets, or quotes based on language. When bound to a shortcut, allow options to show line count and char count between match in the status bar. Highlight basic brackets within strings. Works with multi-select. Configurable custom gutter icons. Toggle bracket escape mode for string brackets (regex|string). Bracket plugins that can jump between bracket ends, select content, etc.","title":"Feature List"},{"location":"#credits","text":"pyparadigm: for his original efforts with SublimeBrackets and SublimeTagmatcher which originally BracketHighlighter was built off of and the inspiration for this project. BoundInCode: for his Tag icon.","title":"Credits"},{"location":"contributing/","text":"Contributing & Support Overview Sublime Versions Description ST2 Supported on a separate branch, but not actively. Any further fixes or enhancements must come from the community. Issues for versions less than ST3 will not be addressed moving forward by me. Pull requests are welcome for back-porting features, enhancements, or fixes to the old branch, but the content of the pull must already exist on the main, actively developed branch. I will not allow an older branch to exceed the main branch in regards to functionality. ST3 Fully supported and actively maintained. Contribution from the community is encouraged and can be done in a variety of ways: Bug reports. Reviewing code. Code patches via pull requests. Documentation improvements via pull requests. Bracket Rules are Supported by the Community The most common requested enhancement for BracketHighlighter is for new rules to add support for {insert your favorite language here}. I, like you, am proficient in very specific languages. I probably don't use your favorite language or there would already be a support for it. I don't have time to learn the nuances of your language. For these reasons, support for new language brackets requires pull requests from the community. Though I will not personally implement rules for your favorite language, I am more than willing to offer suggestions and guidance to help those who may struggle to create rules for their specific language of interest. Bug Reports Please read the documentation and search the issue tracker to try to find the answer to your question before posting an issue. When an issue is created, a template will be shown, please fill out the appropriate sections. If the template is not followed, the issue will be marked Invalid and closed. When creating an issue on the repository, please provide as much info as possible. The template will reiterate what is mentioned here as a reminder: Provide environment information by running Preferences->Package Settings->BracketHighlighter->Support Info . The information will be copied to the clipboard; paste the info in issue. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format as well for easy copy/paste. Provide links to 3 rd party syntax highlighting package you are using if applicable. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Pull Requests Pull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of. Please describe the change in as much detail as possible so I can understand what is being added or modified. If you are solving a bug that does not already have an issue, please describe the bug in detail and provide info on how to reproduce if applicable (this is good for me and others to reference later when verifying the issue has been resolved). Please reference and link related open bugs or feature requests in this pull if applicable. Make sure you've documented or updated the existing documentation if introducing a new feature or modifying the behavior of an existing feature that a user needs to be aware of. I will not accept new features or changes to existing features if you have not provided documentation describing the feature. Continuous integration tests on are run on all pull requests and commits via Travis CI. When making a pull request, the tests will automatically be run, and the request must pass to be accepted. You can (and should) run these tests before pull requesting. If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge. Running Validation Tests Tip If you are running Sublime on a OSX or Linux/Unix system, you run all tests by by running the shell script (assuming you have installed your environment fulfills all requirements below): chmod +x run_tests.sh ./run_tests.sh There are a couple of dependencies that must be present before running the tests. As ST3 is the only current, actively supported version, Python 3.3 must be used to validate the tests. Unit tests are run with pytest ( pytest-dev/pytest ). You can install pytest via: pip install pytest The tests should be run from the root folder of the plugin by using the following command: pytest . Linting is performed on the entire project with the following modules: pycqa/flake8 pycqa/flake8-docstrings ebeweber/flake8-mutable gforcada/flake8-builtins pycqa/pep8-naming These can be installed via: pip install flake8 pip install flake8-docstrings pip install flake8-mutable pip install flake8-builtins pip install pep8-naming Linting is performed with the following command: flake8 . Documentation Improvements A ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation. Help with documentation is always appreciated and can be done via pull requests. There shouldn't be any need to run validation tests if only updating documentation. You don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of mkdocs/mkdocs , the squidfunk/mkdocs-material , and facelessuser/pymdown-extensions to render the docs. You can preview the docs if you install these two packages. The command for previewing the docs is mkdocs serve from the root directory. You can then view the documents at localhost:8000 .","title":"Contributing &amp; Support"},{"location":"contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"contributing/#overview","text":"Sublime Versions Description ST2 Supported on a separate branch, but not actively. Any further fixes or enhancements must come from the community. Issues for versions less than ST3 will not be addressed moving forward by me. Pull requests are welcome for back-porting features, enhancements, or fixes to the old branch, but the content of the pull must already exist on the main, actively developed branch. I will not allow an older branch to exceed the main branch in regards to functionality. ST3 Fully supported and actively maintained. Contribution from the community is encouraged and can be done in a variety of ways: Bug reports. Reviewing code. Code patches via pull requests. Documentation improvements via pull requests. Bracket Rules are Supported by the Community The most common requested enhancement for BracketHighlighter is for new rules to add support for {insert your favorite language here}. I, like you, am proficient in very specific languages. I probably don't use your favorite language or there would already be a support for it. I don't have time to learn the nuances of your language. For these reasons, support for new language brackets requires pull requests from the community. Though I will not personally implement rules for your favorite language, I am more than willing to offer suggestions and guidance to help those who may struggle to create rules for their specific language of interest.","title":"Overview"},{"location":"contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try to find the answer to your question before posting an issue. When an issue is created, a template will be shown, please fill out the appropriate sections. If the template is not followed, the issue will be marked Invalid and closed. When creating an issue on the repository, please provide as much info as possible. The template will reiterate what is mentioned here as a reminder: Provide environment information by running Preferences->Package Settings->BracketHighlighter->Support Info . The information will be copied to the clipboard; paste the info in issue. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format as well for easy copy/paste. Provide links to 3 rd party syntax highlighting package you are using if applicable. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"contributing/#pull-requests","text":"Pull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of. Please describe the change in as much detail as possible so I can understand what is being added or modified. If you are solving a bug that does not already have an issue, please describe the bug in detail and provide info on how to reproduce if applicable (this is good for me and others to reference later when verifying the issue has been resolved). Please reference and link related open bugs or feature requests in this pull if applicable. Make sure you've documented or updated the existing documentation if introducing a new feature or modifying the behavior of an existing feature that a user needs to be aware of. I will not accept new features or changes to existing features if you have not provided documentation describing the feature. Continuous integration tests on are run on all pull requests and commits via Travis CI. When making a pull request, the tests will automatically be run, and the request must pass to be accepted. You can (and should) run these tests before pull requesting. If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge.","title":"Pull Requests"},{"location":"contributing/#running-validation-tests","text":"Tip If you are running Sublime on a OSX or Linux/Unix system, you run all tests by by running the shell script (assuming you have installed your environment fulfills all requirements below): chmod +x run_tests.sh ./run_tests.sh There are a couple of dependencies that must be present before running the tests. As ST3 is the only current, actively supported version, Python 3.3 must be used to validate the tests. Unit tests are run with pytest ( pytest-dev/pytest ). You can install pytest via: pip install pytest The tests should be run from the root folder of the plugin by using the following command: pytest . Linting is performed on the entire project with the following modules: pycqa/flake8 pycqa/flake8-docstrings ebeweber/flake8-mutable gforcada/flake8-builtins pycqa/pep8-naming These can be installed via: pip install flake8 pip install flake8-docstrings pip install flake8-mutable pip install flake8-builtins pip install pep8-naming Linting is performed with the following command: flake8 .","title":"Running Validation Tests"},{"location":"contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation. Help with documentation is always appreciated and can be done via pull requests. There shouldn't be any need to run validation tests if only updating documentation. You don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of mkdocs/mkdocs , the squidfunk/mkdocs-material , and facelessuser/pymdown-extensions to render the docs. You can preview the docs if you install these two packages. The command for previewing the docs is mkdocs serve from the root directory. You can then view the documents at localhost:8000 .","title":"Documentation Improvements"},{"location":"customize/","text":"Customizing Overview BH is extremely flexible and can be customized and extended to fit a user's needs. The first step to customizing the existing rules and settings is to create a bh_core.sublime-settings in your User folder. With this file you can override any of the settings or bracket rules. By changing these settings, you can add support for new languages, or change the look of highlighting, and much more. Core Visual Settings These are the settings related to the visual appearance of BH . show_in_minimap Shows highlighted brackets in the minimap. This will work with all highlight styles except underline ; thin_underline has no issues. // Show brackets in the minimap. \"show_in_minimap\" : false , show_unmatched Displays a special highlight for brackets that cannot be matched. // When only either the left or right bracket can be found // this defines if the unmatched bracket should be shown. \"show_unmatched\" : true , show_unmatched_exceptions List of languages in which the show_unmatched option logic will be reversed. // Do the opposite of \"show_unmatched\" for the languages listed below \"show_unmatched_exceptions\" : [], content_highlight_bar An experimental setting which can enable the display of a vertical bar that extends from the line containing the opening bracket to the line with the closing bracket. Takes a boolean of true or false . When align_content_highlight_bar is set to false , the bar will be shown on the first column regardless of indent level of the brackets. When align_content_highlight_bar is set to true , the bar will be aligned at the bracket indent level. // Experimental: Creates a visible bar at the beginning of all lines between // multiline bracket spans. \"content_highlight_bar\" : false , show_in_widgets An experimental setting that enables bracket highlighting in widgets (panels etc.). By default, BH does not highlight any brackets in plain text which is what the majority of the widget text boxes are. Regex search boxes are not plain text and should get bracket highlighting. // Experimental: Allow bracket highlighter to search in widgets. // Most widgets use Plain Text which BH should ignore, // But regex find views views are usually regular expression // Which should be the only views to trigger BH. \"search_in_widgets\" : false , Output panels are widgets as well, but sometimes the widget flag gets removed from them (Sublime issue). So this flag may or may not affect the output panel depending on its state. If you are a developer and wish to ensure an output panel that is created by your plugin does not have bracket highlighting, you can set the following setting to the view as True : bracket_highlighter.ignore . align_content_highlight_bar Modifies the behavior of content_highlight_bar and draws the vertical content bar at the indentation level of the highlighted bracket, but there are some limitations: The content bar cannot extend through an empty line unless the bar is on the first column. This is a limitation of the Sublime API. Empty lines will cause a gap in the bar. The content bar will not be shown on a line where non-whitespace characters cross the bar. // Experimental: Align the content highlight bar at the bracket indent level \"align_content_highlight_bar\" : false , high_visibility_enabled_by_default Enables high visibility mode by default. High visibility mode highlights not only the bracket but the content between as well, but it is disabled by default and must be toggled on to be used. This reverses the behavior and has it on by default. Takes a boolean true or false . // Enable high visibility by default when sublime starts up \"high_visibility_enabled_by_default\" : false , high_visibility_style Modifies the styling of high visibility mode. The available options are solid , outline , underline , thin_underline , squiggly , and stippled . // High visibility style and color for high visibility mode \"high_visibility_style\" : \"outline\" , high_visibility_color Modifies the high visibility color. There are three types of settings you can use: __default__ is a special reserved value which will use the color set in bracket_styles . See Configuring Highlight Style for more info. __bracket__ is a special reserved value which will inherit the defined color of the highlighted bracket. Any valid scope found in your color scheme. // Color for high visibility mode \"high_visibility_color\" : \"__bracket__\" , Behavioral Settings These settings affect the matching behavior. match_only_adjacent Causes BH to only match and highlight brackets when the cursor is adjacent to a bracket. // Match brackets only when the cursor is touching the inside of the bracket \"match_only_adjacent\" : false , bracket_outside_adjacent Augments the matching behavior and will trigger matching when the cursor is adjacent to a cursor on the outside (not between the brackets). // Outside adjacent bracket matching \"bracket_outside_adjacent\" : true , block_cursor_mode Experimental setting that modifies the bracket matching mode for block cursor. The bracket matching mode is one that makes a little more sense to some people in regards to the visual representation of block cursors. In this mode, brackets will match when the cursor is right before the bracket (or if using a block cursor, highlighting the character). So if you are someone that uses block cursors and find that toggling bracket_outside_adjacent still doesn't quite match brackets how you would like, you can give this setting a try. It has also been mentioned that this makes sense with Vim. When this setting is enabled, bracket_outside_adjacent will be ignored. // Experimental: Special matching mode for block cursor. // Essentially, this provides a matching mode that makes a little more // sense to some in regards to the visual representation of block cursors. // This will ignore \"bracket_outside_adjacent\". \"block_cursor_mode\" : false , ignore_outside_adjacent_in_plugin Ignores the bracket_outside_adjacent setting when running a plugin if the plugin sets no_outside_adj to null ( null for JSON or None in Python). // When \"bracket_outside_adjacet\" is set, and a plugin command explicitly sets // \"no_outside_adj\" \"None\" instead of \"true\" or the default \"false\", // this value will be used. \"ignore_outside_adjacent_in_plugin\" : true , ignore_block_mode_in_plugin Experimental setting that ignores the block_cursor_mode setting when running a plugin if the plugin sets no_block_mode to null ( null for JSON or None in Python). // When \"block_cursor_mode\" is set, and a plugin command explicitly sets // \"no_block_mode\" to \"None\" instead of \"true\" or the default \"false\", // this value will be used. \"ignore_block_mode_in_plugin\" : true , bracket_string_escape_mode Depending on the setting, BH will either match sub-brackets inside strings with traditional string escape logic, or it will match sub-brackets in strings with regex escape logic. Takes a string value of either regex or string . // Set mode for string escapes to ignore (regex|string) \"bracket_string_escape_mode\" : \"string\" , search_threshold Sets the search threshold. The search threshold determines how many characters BH will search through to find matching brackets before giving up. This setting only affects auto-matching and not on-demand calls from the command palette and menu. By default, this value is very conservative and can be increased. Keep in mind that a very large value may impact performance. // Character threshold to search \"search_threshold\" : 5000 , ignore_threshold Causes the search_threshold limit to be ignored. It is not advised to use this as very large files may cause a noticeable performance hit, but has been made available due to a number of requests. // Ignore threshold \"ignore_threshold\" : false , auto_selection_threshold A numerical value which controls the maximum number of simultaneous auto-matched brackets that are allowed. This setting will not be considered when running on-demand calls via the command palette or menu. // Set max number of multi-select brackets that will be searched automatically \"auto_selection_threshold\" : 10 , kill_highlight_on_threshold Completely kills highlighting when auto_selection_threshold is exceeded. When disabled, BH will just highlight up to the threshold limit. // Enable this to completely kill highlighting if \"auto_selection_threshold\" // is exceeded. Default is to highlight up to the \"auto_selection_threshold\". \"kill_highlight_on_threshold\" : true , gutter_icons Globally enable or disable gutter icons. // Global control of gutter icons. \"gutter_icons\" : true , no_multi_select_icons Disables gutter icons when doing multiple selections. // Disable gutter icons when doing multi-select \"no_multi_select_icons\" : false , Popup Settings Settings related to the new popup hints when brackets are offscreen. show_offscreen_bracket_popup Setting this will show a popup when the mouse hovers over a visible bracket and its matching pair is offscreen. The popup will show about 120 chars of context for every line shown. Additionally, if the offscreen bracket is located on a separate line, it will show an additional line(s) of context before and after. The context is shown in plain text, but the bracket will be emphasized by making the bracket bold and colorizing it with the your theme's keyword color. Character context , line context , and emphasis color can all be configured in the settings file. If a bracket was unmatched with an invalid highlight, you can mouse over it and will get the unmatched popup that explains the reasons why an unmatched bracket might occur. It also offers the option to attempt matching without the threshold. // Show hover popup // This will show a hover popup when mousing over // the visible bracket if the other // highlighted matching bracket is off screen. // It will show line text of the off screen bracket -/+ 128 chars // from the bracket start and end points. // A link will be available allowing the user to click and jump to // the other bracket. \"show_offscreen_bracket_popup\" : false , show_bracket_popup_always If this setting is enabled with show_offscreen_bracket_popup , the bracket popup will always be shown on bracket hover, even if both brackets are onscreen. // If enabled with `show_offscreen_bracket_popup`,the popup will be shown // even if brackets are onscreen. \"show_bracket_popup_always\" : false , popup_char_context This determines the amount of characters per line of context that are allowed in the popup that is generated by show_offscreen_bracket_popup . By default, this setting is set to 120 . If you desire a different amount, you can specify it here. // Adjust char per line context of bracket popup. \"popup_char_context\" : 120 , popup_line_context Setting this determines the amount of additional lines of context that are allowed in the popup that is generated by show_offscreen_bracket_popup . popup_line_context is only applied to brackets that are not on the same line as the visible bracket. This value is split and half the lines will be gathered from before the line of interest and half from after the line of interest. It is recommend to use even numbers. Line context is a bit dynamic in the sense that if X number of lines cannot be gathered from before, the additional lines will be applied after; the inverse is true in regards to lines after. // Adjust number of lines of additional context // that are shown when brackets are vertically off screen. // Specified line count is split to context before and after the target line. // So a value of 4 would give you two lines of context before and two lines after. \"popup_line_context\" : 2 , use_custom_popup_bracket_emphasis This experimental setting allows you to override the default popup bracket emphasis which is calculated based on what scope/color you have assigned to the matched bracket style. With this setting enabled, you can use the setting popup_bracket_emphasis to control the color of the popup bracket emphasis. This will default to true if you don't have the MdPopups version which supports guessing the correct color. // Use 'popup_bracket_emphasis' to customize the popup's bracket emphasis color \"use_custom_popup_bracket_emphasis\" : false , popup_bracket_emphasis This setting dictates what color is used to emphasize the off screen bracket in the popup that is generated by show_offscreen_bracket_popup . Colors can either be specified by a standard TextMate scopes (the popup library being used is MdPopups, and it scans your theme for standard TextMate scopes and creates the necessary CSS for the popups), or you can specify a hex color in the form of #rgb or #rrggbb . Due to limitations in Sublime's HTML renderer, scopes that define background colors will most likely not show the background color. The default setting is #ff0000 . Outside of the scopes generated by MdPopups, it is likely that your theme may have additionally included scopes. Sublime seems to include these by default (but your mileage may vary): error deleted success inserted warning modified // Specify the scope (to get color) to emphasize the off screen bracket // in popups. Alternatively you can use a hex value in the form '#rgb' or '#rrggbb'. \"popup_bracket_emphasis\" : \"keyword\" Special Settings debug Turn on debug logging. Set to true to enable or false to disable. //Debug logging \"debug_enable\" : false , Tag Plugin Settings This section covers settings found in bh_tag.sublime-settings . All tag settings are dictionaries. Each key represents a tag mode such as: html , xhtml , cfml , etc. All of these are exposed so that even non-standard HTML syntax can be supported. Attention! More tag mode keys can be added, but they must be added to every setting with valid parameters. tag_mode A list that contains a dictionary of different modes. Each mode tweaks the tag matching for the respective mode. Each entry in the list consists of a dictionary with the keys mode , syntax , and the optional first_line . mode specifies the mode name. syntax is a list of languages that are allowed in that mode. first_line (which is optional) is a regular expression that is applied to the first line in the file as a condition for selecting that mode. The tag_mode list is evaluated in order from top to bottom and selects the first entry that matches all the criteria. // Determine which style of tag-matching to use in which syntax. \"tag_mode\" : [ { \"mode\" : \"xml\" , \"syntax\" : [ \"XML\" ]}, { \"mode\" : \"xhtml\" , \"syntax\" : [ \"HTML\" , \"HTML 5\" , \"PHP\" , \"HTML (Jinja Templates)\" , \"HTML (Jinja2)\" , \"HTML (Rails)\" , \"HTML (Twig)\" , \"HTML (Django)\" , \"laravel-blade\" , \"blade\" , \"Handlebars\" , \"AngularJS\" , \"Java Server Pages (JSP)\" ], \"first_line\" : \"^[ \\\\t]*<\\\\?xml\" }, { \"mode\" : \"html\" , \"syntax\" : [ \"HTML\" , \"HTML 5\" , \"PHP\" , \"HTML (Jinja Templates)\" , \"HTML (Jinja2)\" , \"HTML (Rails)\" , \"HTML (Twig)\" , \"HTML (Django)\" , \"laravel-blade\" , \"blade\" , \"Handlebars\" , \"AngularJS\" , \"Java Server Pages (JSP)\" ] }, { \"mode\" : \"cfml\" , \"syntax\" : [ \"CFML\" , \"HTML+CFML\" , \"ColdFusion\" , \"ColdFusionCFC\" ] } ], tag_style Sets the highlight style for the tag plugin. The string value should correspond to a style entry in bracket_styles . See Configuring Highlight Style for more info. // Style to use for matched tags \"tag_style\" : { \"xhtml\" : \"tag\" , \"html\" : \"tag\" , \"cfml\" : \"tag\" }, tag_scope_exclude Excludes certain scopes from being evaluated when searching for tags. // Scopes to exclude from tag searches. \"tag_scope_exclude\" : { \"xhtml\" : [ \"string\" , \"comment\" ], \"html\" : [ \"string\" , \"comment\" ], \"cfml\" : [ \"string\" , \"comment\" ] }, optional_tag_patterns Specifies a regex pattern for names that will be evaluated as optional tags. Optional tags are tags whose closing tag is optional. In the case of optional tags, you may only have an opening (with no self closing slash). null can be used to specify that there is no pattern for the specified tag mode. // Optional closing HTML tags. You can use 'null' if it does not require a pattern. \"optional_tag_patterns\" : { \"xml\" : null , \"xhtml\" : null , \"html\" : \"colgroup|dd|dt|li|options|p|td|tfoot|th|thead|tr\" , \"cfml\" : \"cf.+|colgroup|dd|dt|li|options|p|td|tfoot|th|thead|tr\" }, void_tag_patterns Specifies a regex pattern for names that never have a closing tag. Void or empty tags can optionally use the self closing slash: <tag /> . null can be used to specify that there is no pattern for the specified tag mode. // Tags that never have a closing. You can use 'null' if it does not require a pattern. \"void_tag_patterns\" : { \"xml\" : null , \"xhtml\" : null , \"html\" : \"area|base|basefont|br|col|embed|frame|hr|img|input|isindex|keygen|link|meta|param|source|track|wbr\" , \"cfml\" : \"area|base|basefont|br|col|embed|frame|hr|img|input|isindex|keygen|link|meta|param|source|track|wbr\" }, self_closing_tag_patterns Specifies a regex pattern for tag names that can be represented in self closing form: <tag /> . null can be used to specify that there is no pattern for the specified tag mode. // Self closing tags. Single tags that are closed like this <tag /> \"self_closing_tag_patterns\" : { \"xml\" : \"[\\\\w:\\\\.\\\\-]+\" , \"xhtml\" : \"[\\\\w:\\\\.\\\\-]+\" , \"html\" : null , \"cfml\" : \"cf.+\" }, tag_name Specifies the regex pattern for identifying the tag name for a given tag mode. This is broken out as a separate pattern because the Tag Attribute Select bh_plugin needs access to the tag name and tag attributes separate from the whole HTML tag regex. // Regex for tag name. Do not use capturing groups. \"tag_name\" : { \"xhtml\" : \"[\\\\w:\\\\.\\\\-]+\" , \"html\" : \"[\\\\w:\\\\.\\\\-]+\" , \"cfml\" : \"[\\\\w:\\\\.\\\\-]+\" }, attributes Specifies the regex pattern for identifying the tag attributes for a given tag mode. This is broken out as a separate pattern so that because the Tag Attribute Select bh_plugin needs access to the tag_name and tag attributes separate from the whole HTML tag regex. // HTML attributes. Do not use capturing groups. \"attributes\" : { \"xhtml\" : \"[\\\\w\\\\-:]+(?:\\\\s*=\\\\s*(?:\\\"(?:\\\\.|[^\\\"])*\\\"|'(?:\\\\.|[^'])*'))?\" , \"html\" : \"[\\\\w\\\\-:]+(?:\\\\s*=\\\\s*(?:\\\"[^\\\"]*\\\"|'[^']*'|[^\\\\s\\\"'`=<>]+))?\" , \"cfml\" : \"[\\\\w\\\\-\\\\.:]+(?:\\\\s*=\\\\s*(?:\\\"[^\\\"]*\\\"|'[^']*'|[^\\\\s\\\"'`=<>]+))?\" }, start_tag Specifies the starting/opening tag regex. The pattern can accept the tag name and attribute portion of the pattern from the tag_name and attributes settings via the python string formatting variables tag_name and attributes (see example below). // Regex for start/opening tag. Use a capturing group for tag name and self closing indicator '/' only. // Attributes and tag names are inserted using python string formatting: // the keyword 'attributes' and `tag_name` are used. \"start_tag\" : { \"xhtml\" : \"<(%(tag_name)s)(?:\\\\s+%(attributes)s)*\\\\s*(/?)>\" , \"html\" : \"<(%(tag_name)s)(?:\\\\s+%(attributes)s)*\\\\s*(/?)>\" , \"cfml\" : \"<(%(tag_name)s)(?:(?:\\\\s+%(attributes)s)*|(?:(?<=cfif)|(?<=cfelseif))[^>]+)\\\\s*(/?)>\" }, end_tag Specifies the ending/closing tag regex. // Regex for end/closing tag. Only use a capturing group for name. \"end_tag\" : { \"xhtml\" : \"</([\\\\w\\\\:\\\\.\\\\-]+)[^>]*>\" , \"html\" : \"</([\\\\w\\\\:\\\\.\\\\-]+)[^>]*>\" , \"cfml\" : \"</([\\\\w\\\\:\\\\.\\\\-]+)[^>]*>\" } Swap Brackets Plugin Settings Swappable brackets for a given language can be defined in bh_swapping.sublime-settings . Swap rules are found under the key swapping where swapping is an array of language swap rules. \"swapping\" : [ { \"enabled\" : true , \"language_list\" : [ \"C++\" , \"C\" ], \"language_filter\" : \"allowlist\" , \"entries\" : [ { \"name\" : \"C/C++: #if\" , \"brackets\" : [ \"#if ${BH_SEL}\" , \"#endif\" ]}, { \"name\" : \"C/C++: #if, #else\" , \"brackets\" : [ \"#if${BH_SEL}\" , \"#else\\n${BH_TAB:/* CODE */}\\n#endif\" ]}, { \"name\" : \"C/C++: #if, #elif\" , \"brackets\" : [ \"#if${BH_SEL}\" , \"#elif ${BH_TAB:/* CONDITION */}\\n${BH_TAB:/* CODE */}\\n#endif\" ]}, { \"name\" : \"C/C++: #ifdef\" , \"brackets\" : [ \"#ifdef${BH_SEL}\" , \"#endif\" ]}, { \"name\" : \"C/C++: #ifdef, #else\" , \"brackets\" : [ \"#ifdef${BH_SEL}\" , \"#else\\n${BH_TAB:/* CODE */}\\n#endif\" ]}, { \"name\" : \"C/C++: #ifndef\" , \"brackets\" : [ \"#ifndef${BH_SEL}\" , \"#endif\" ]}, { \"name\" : \"C/C++: #ifndef, #else\" , \"brackets\" : [ \"#ifndef${BH_SEL}\" , \"#else\\n${BH_TAB:/* CODE */}\\n#endif\" ]} ] } ] Each language rule contains the following attributes: Attribute Type Description enabled bool Specifies if the rule is enabled. language_list [string] An array of languages. language_filter string A string that specifies whether the language_list is either a allowlist or blocklist . entries [dict] An array of dictionaries, where each dictionary describes a type of bracket that can be swapped to. The entries key is used to define the related bracket swap rules for the given language. Each entry represents a bracket you can swap to. Entry Type Description name string The name of the entry as it will be seen in the command palette. brackets [string] An array consisting of a string that represents the opening bracket and a string that represents the closing bracket. Within the brackets key, you can specify where the cursor(s) will appear by using ${BH_SEL} . If you would like the selection to display text as a hint to what a user should enter in the selection, you can use ${BH_SEL:optional text} . You can also define tab stops that a user can tab through and enter text. The tab stop syntax is ${BH_TAB} . You can also define optional text within a tab stop to give the user a hint of what should be entered using the following syntax: ${BH_TAB:optional text} . Wrap Brackets Plugin Settings Wrapping brackets for a given language can be defined in bh_wrapping.sublime-settings . Wrap rules are found under the key wrapping where wrapping is an array of language wrap rules. \"wrapping\" : [ { \"enabled\" : true , \"language_list\" : [ \"Plain text\" ], \"language_filter\" : \"blocklist\" , \"entries\" : [ { \"name\" : \"{} Curly\" , \"brackets\" : [ \"{\" , \"}${BH_SEL}\" ], \"insert_style\" : [ \"inline\" , \"block\" , \"indent_block\" ]} ] } ] Each language rule contains the following attributes: Attribute Type Description enabled bool Specifies if the rule is enabled. language_list [string] An array of languages. language_filter string A string that specifies if the language_list is either a allowlist or blocklist . entries [dict] An array of dictionaries, where each dictionary describes a type of bracket that can be used to wrap the selection. The entries key is used to define the related bracket wrap rules for the given language. Each entry represents a bracket you can wrap the selection with. Entry Type Description name string The name of the entry as it will be seen in the command palette. brackets [string] An array consisting of a string that represents the opening bracket and a string that represents the closing bracket. insert_style [string] An array consisting of allowed insertion styles. Allowed insertion styles are: inline , block , and indent_block . Default is [ 'inline' ] . Within the brackets key, you can specify where the cursor(s) will appear by using ${BH_SEL} . If you would like the selection to display text as a hint to what a user should enter in the selection, you can use ${BH_SEL:optional text} . You can also define tab stops that a user can tab through and enter text. The tab stop syntax is ${BH_TAB} . You can also define optional text within a tab stop to give the user a hint of what should be entered using the following syntax: ${BH_TAB:optional text} . Configuring Brackets BH has been written to allow users the ability to define any bracket they would like to have highlighted. Bracket rules are defined with case insensitive regular expressions, syntax scoping, and bh_plugins . There are two kinds of brackets you can define. scope_brackets which search the file for scope regions and then use regex to test for opening and closing brackets. brackets which use regex to find opening and closing brackets. The brackets rules should usually be the preferred type. scope_brackets are usually used for brackets whose opening and closing are the same. These type are not easily distinguishable from one another by regex. Scope brackets must be contained in a continuous scope region like string for quotes etc. BH uses a wrapper around Python's re regex library to add support for additional back references. See the Extended Regex Guide . Tip Brackets can be modified, or even added, without copying the entire bracket rule list to the user settings. See Bracket Rule Management for more info. Configuring Brackets Rules Brackets are defined under brackets in bh_core.sublime-settings . angle and curly brackets will be used as an example (not all options may be shown in these examples): { \"name\" : \"angle\" , \"open\" : \"(<)\" , \"close\" : \"(>)\" , \"style\" : \"angle\" , \"scope_exclude\" : [ \"string\" , \"comment\" , \"keyword.operator\" ], \"language_filter\" : \"allowlist\" , \"language_list\" : [ \"HTML\" , \"HTML 5\" , \"XML\" , \"PHP\" , \"CFML\" , \"HTML+CFML\" , \"ColdFusion\" , \"ColdFusionCFC\" ], \"plugin_library\" : \"bh_modules.tags\" , \"enabled\" : true }, { \"name\" : \"curly\" , \"open\" : \"(\\\\{)\" , \"close\" : \"(\\\\})\" , \"style\" : \"curly\" , \"scope_exclude\" : [ \"string\" , \"comment\" ], \"scope_exclude_exceptions\" : [ \"string.other.math.block.environment.latex\" ], \"language_filter\" : \"blocklist\" , \"language_list\" : [ \"Plain text\" ], \"find_in_sub_search\" : \"true\" , \"ignore_string_escape\" : true , \"enabled\" : true }, Parameter Description name The name of the bracket (should be unique). open Defines the opening bracket (one and only one capturing group must be present). close Defines the closing bracket (one and only one capturing group must be present). style Name of the style definition to be used to highlight the brackets. See Configuring Bracket Styles for more info. scope_exclude Scopes where the opening and closing brackets should be ignored. language_filter This works in conjunction with language_list . It specifies whether language_list is a blocklist or allowlist . language_list An array of tmLanguage file names that should be avoided or included for highlighting. Looks to language_filter to determine if avoidance or inclusion is used. enabled Disable or enable rule. scope_exclude_exceptions (optional) Used to ignore excluding of sub scopes such as in the curly example above where string is excluded, but not string.other.math.block.environment.latex . plugin_library (optional) Defines a plugin to use for determining matches (see Bracket Plugin API for more info on matching plugins). find_in_sub_search (optional) This rule should be included when doing sub bracket matching in scope_brackets (like finding round brackets between quotes etc.). The setting must be a string and can be either true , false , or only ; only means this bracket is only matched as a sub bracket of a scope_bracket . ignore_string_escape (optional) Do not ignore sub brackets found in strings and regex when escaped, but use internal escape logic to determine if the brackets should be ignored based on whether regex or string escape mode is set. Configuring Scope Brackets Rules Scope Brackets are defined under scope_brackets in bh_core.sublime-settings . py_single_quote bracket will be used as an example (not all options are shown in this example): { \"name\" : \"py_single_quote\" , \"open\" : \"u?r?((?:'')?')\" , \"close\" : \"((?:'')?')\" , \"style\" : \"single_quote\" , \"scopes\" : [ \"string\" ], \"language_filter\" : \"allowlist\" , \"language_list\" : [ \"Python\" ], \"sub_bracket_search\" : \"true\" , \"enabled\" : true }, Parameters Description name The name of the bracket (should be unique). open Defines the opening bracket (one and only one capturing group must be present). close Defines the closing bracket (one and only one capturing group must be present). style Name of the style definition to be used to highlight the brackets. See Configuring Bracket Styles for more info. scopes Scope that should be searched to find the opening and closing brackets. language_filter This works in conjunction with language_list . It specifies whether language_list is a blocklist or allowlist . language_list An array of tmLanguage file names that should be avoided or included for highlighting. Looks to language_filter to determine if avoidance or inclusion is used. sub_bracket_search Specifies whether this scope bracket also searches for sub brackets (like curly brackets in strings etc.). enabled Disable or enable rule. plugin_library (optional) Defines plugin to use for determining matches (see Bracket Plugin API for more info on matching plugins). Bracket Rule Management In the past, BracketHighlighter required a user to copy the entire bracket list to the user bh_core.sublime-settings file. This was a cumbersome requirement that also punished a user because if they did this, they wouldn't automatically get updates to the rules as all the rules were now overridden by the user's settings file. BracketHighlighter now lets you add or modify existing rules without overriding the entire rule set, or even the entire target rule. Let's say you have a custom language you want to have on your machine. Now, you can simply add it to one of the two settings arrays: \"user_scope_brackets\" and \"user_brackets\": \"user_scope_brackets\" : [], \"user_brackets\" : [ { \"name\" : \"mylang\" , \"open\" : \"^\\\\s*\\\\b(if|subr|bytemap|enum|command|for|while|macro|do)\\\\b\" , \"close\" : \"\\\\b(e(?:if|subr|bytemap|enum|command|for|while|macro)|until)\\\\b\" , \"style\" : \"default\" , \"scope_exclude\" : [ \"string\" , \"comment\" ], \"plugin_library\" : \"User.bh_modules.mylangkeywords\" , \"language_filter\" : \"allowlist\" , \"language_list\" : [ \"mylang\" ], \"enabled\" : true } ], Let's say you want to modify an existing rule, maybe just tweak the language list. All you have to do is use the same name of the item you want to change. Only that attribute will be overridden: \"user_brackets\" : [ // Angle { \"name\" : \"angle\" , \"language_list\" : [ \"HTML\" , \"HTML 5\" , \"XML\" , \"PHP\" , \"HTML (Rails)\" , \"HTML (Jinja Templates)\" , \"HTML (Jinja2)\" , \"HTML (Twig)\" , \"CFML\" , \"HTML+CFML\" , \"ColdFusion\" , \"ColdFusionCFC\" , \"laravel-blade\" , \"Handlebars\" , \"AngularJS\" , \"SomeNewLanguage\" // <--- New language ] } ], Let's say you want to insert a new rule between two rules. You can turn on debug mode and call the BracketHighlighter: (Debug) Filter Rules by Key , and then select position to see the current rule order and their position index. To turn on Debug mode, just add \"debug_enable\" : true to your user settings file. Example of BracketHighlighter: (Debug) Filter Rules by Key output: [ [ { \"name\" : \"curly\" , \"position\" : 0 }, { \"name\" : \"round\" , \"position\" : 1 }, { \"name\" : \"square\" , \"position\" : 2 }, { \"name\" : \"html\" , \"position\" : 3 }, { \"name\" : \"cfml\" , \"position\" : 4 }, { \"name\" : \"php_angle\" , \"position\" : 5 }, { \"name\" : \"angle\" , \"position\" : 6 }, { \"name\" : \"cssedit_groups\" , \"position\" : 7 }, { \"name\" : \"ruby_embedded_html\" , \"position\" : 8 }, { \"name\" : \"ruby\" , \"position\" : 9 }, { \"name\" : \"c_compile_switch\" , \"position\" : 10 }, { \"name\" : \"php_keywords\" , \"position\" : 11 }, { \"name\" : \"erlang\" , \"position\" : 12 }, { \"name\" : \"bash\" , \"position\" : 13 }, { \"name\" : \"fish\" , \"position\" : 14 }, { \"name\" : \"mylang\" , \"position\" : 15 } ], [ { \"name\" : \"py_single_quote\" , \"position\" : 0 }, { \"name\" : \"py_double_quote\" , \"position\" : 1 }, { \"name\" : \"single_quote\" , \"position\" : 2 }, { \"name\" : \"double_quote\" , \"position\" : 3 }, { \"name\" : \"jsregex\" , \"position\" : 4 }, { \"name\" : \"perlregex\" , \"position\" : 5 }, { \"name\" : \"rubyregex\" , \"position\" : 6 }, { \"name\" : \"mditalic\" , \"position\" : 7 }, { \"name\" : \"mdbold\" , \"position\" : 8 } ] ] Then you can specify the position you want to insert at using the position key: \"user_scope_brackets\" : [], \"user_brackets\" : [ { \"name\" : \"mylang\" , \"position\" : 4 , // <-- New position \"open\" : \"^\\\\s*\\\\b(if|subr|bytemap|enum|command|for|while|macro|do)\\\\b\" , \"close\" : \"\\\\b(e(?:if|subr|bytemap|enum|command|for|while|macro)|until)\\\\b\" , \"style\" : \"default\" , \"scope_exclude\" : [ \"string\" , \"comment\" ], \"plugin_library\" : \"User.bh_modules.mylangkeywords\" , \"language_filter\" : \"allowlist\" , \"language_list\" : [ \"mylang\" ], \"enabled\" : true } ], And if you run the debug command again, you will see that the position has changed: { \"name\" : \"curly\" , \"position\" : 0 }, { \"name\" : \"round\" , \"position\" : 1 }, { \"name\" : \"square\" , \"position\" : 2 }, { \"name\" : \"html\" , \"position\" : 3 }, { \"name\" : \"mylang\" , \"position\" : 4 }, // <-- New position { \"name\" : \"cfml\" , \"position\" : 5 }, { \"name\" : \"php_angle\" , \"position\" : 6 }, This can be used to adjust the position of default rules from your user settings as seen in the overrides above. So, unless you are forking BH to pull request a change to the default rules, you can now modify the rules in just these two settings without copying or touching the default rules. This will allow you to make changes, but still receive new updated rules. \"user_scope_brackets\" : [], \"user_brackets\" : [], Configuring Highlight Style Each bracket definition (described in Configuring Scope Brackets and Configuring Brackets ) has a style option that you can assign a specific style to. The name of the style corresponds to a style definition. Style definitions are defined under bracket_styles in bh_core.sublime-settings . Normally you would override the existing style or add new styles through the user_bracket_styles instead of editing bracket_styles directly; direct editing of bracket_styles is mainly reserved for providing defaults to a user. You can add and remove as many styles as you wish, but there are two special style definitions whose names are reserved: default and unmatched . If your remove them, they will be added back automatically in memory, but you can configure them. All styles, even the reserved styles, follow the same format. See description below: // Define region highlight styles \"bracket_styles\" : { \"default\" : { \"icon\" : \"dot\" , \"color\" : \"region.yellowish brackethighlighter.default\" , \"style\" : \"underline\" }, // This particular style is used to highlight // unmatched bracket pairs. It is a special // style. \"unmatched\" : { \"icon\" : \"question\" , \"color\" : \"region.redish\" , \"style\" : \"outline\" }, // User defined region styles \"curly\" : { \"icon\" : \"curly_bracket\" , // \"color\": \"region.purplish\" // \"style\": \"underline\" } } Parameter Description icon Icon to show in gutter. Available options are: angle , round , curly , square , tag , star , dot , bookmark , question , quote , double_quote , single_quote , single_quote_offset , double_quote_offset , none . color Scope to use that defines the color. style Highlight style. Available options are: solid , outline , underline , none . ST3 has additional styles: thin_underline , squiggly , stippled . endpoint Boolean to highlight just the beginning and end of bracket. This is useful for things like tags where it may be distracting highlighting the entire tag. As shown in the example above, an option can be omitted. If an option is omitted it will use the corresponding option in default . If for some reason you've modified default to not have all options, an internal default will be used. So curly , in this example, defines icon , but will use the default definition's color and style . Clearing Up Color Misconceptions Often I am asked why you can't just add a color directly like \"color\" : \"#D04321\" . This is not a decision made by me, but is a limitation of the Sublime API, specifically with region coloring, which is what BH uses to highlight brackets. Sublime needs a scope that exists in your color scheme file. It finds the rule regarding that scope, and applies the color specified in that rule. Around Sublime build 3148, region-ish colors were added. These are scopes that get auto-generated for a color scheme (but can also be explicitly defined) that are meant to define a way for users to pick a specific color that corresponds to the color palette of the theme: region.redish , region.orangish , region.yellowish , region.greenish , region.bluish , region.purplish , and region.pinkish . BH by default uses these now in the color scheme where before it defined nothing, so if you are on Sublime 3148+, you should see colors. If the color scheme creator has not explicitly defined a region-ish color for all the default region-ish colors, Sublime will guess a color that is close. If the palette of the color scheme is limited, you may get colors that don't make sense or situations where the same color is picked for colors that are close to begin with \u2013 like region.purplish and region.pinkish . Example: Adding and Overriding Styles To customize a color, style, or icon, you can simply override that specific style definition by placing your override in user_bracket_styles in your Packages/User/bh_core.sublime-settings file. You are also free to add new styles as well. Just and the key name you want to add/override and specify the options you want to explicitly define, and those specific options will override the existing rule or the defaults. In this example, we will override the exiting curly and only change the color. We will continue to use the icon and style defined defined in the exiting curly rule. We've used the region-ish color region.bluish (for Sublime 3148+) to use the closes color Sublime can find to blue in the existing color scheme. We could have also used any other scope that the color scheme already has rules for. \"user_bracket_styles\" : { \"curly\" : { \"color\" : \"region.bluish\" } } If curly had not already been defined, curly would have been added to the existing rules and any options that were not specified would have inherited their value from the reserved default rule. Example: Specifying Custom Colors in Schemes If you are unsatisfied or unable to use region-ish colors, and are not satisfied with existing scope and color rules in your color scheme, you can modify your color scheme and add the scope and color you wish to use. In Sublime 3152+, you can use the new color format to create an override color scheme instead of directly editing your color scheme. To append your new rule (or override an existing rule) you can create a .sublime-color-scheme file in your Packages/User folder. You only need to specify the colors you are explicitly adding or overriding. In this case, the scheme file would only contain the new scopes we want to append to the base color scheme file. In this case we are adding our own custom region called brackethighligher.curly and assigning a color of #CC99CC . { \"rules\" : [ { \"scope\" : \"brackethighlighter.curly\" , \"foreground\" : \"#CC99CC\" } ] } And now we can use our new scope: \"user_bracket_styles\" : { \"curly\" : { \"icon\" : \"curly_bracket\" \"color\" : \"brackethighlighter.curly\" , // \"style\": \"underline\" } } For Sublime builds <3152, you'd have to actually modify the existing color scheme ( tmTheme ) file that you are using and add your specific scope definition: <dict> <key> name </key> <string> Bracket Curly </string> <key> scope </key> <string> brackethighlighter.curly </string> <key> settings </key> <dict> <key> foreground </key> <string> #CC99CC </string> </dict> </dict> Sublime Color Scheme Example Assuming I was dissatisfied with using the built-in region-ish colors and wanted to create my own scopes (and was on a Sublime build that supports .sublime-color-scheme files), this is how you would it. Override the bracket styles you want to apply a custom scope to (you can do some or all) by placing something similar in Packages/User/bh_core.sublime-settings : // Define region highlight styles { \"user_bracket_styles\" : { \"default\" : { \"color\" : \"brackethighlighter.default\" }, \"unmatched\" : { \"color\" : \"brackethighlighter.unmatched\" }, \"curly\" : { \"color\" : \"brackethighlighter.curly\" }, \"round\" : { \"color\" : \"brackethighlighter.round\" }, \"square\" : { \"color\" : \"brackethighlighter.square\" }, \"angle\" : { \"color\" : \"brackethighlighter.angle\" }, \"tag\" : { \"color\" : \"brackethighlighter.tag\" }, \"c_define\" : { \"color\" : \"brackethighlighter.c_define\" }, \"single_quote\" : { \"color\" : \"brackethighlighter.quote\" }, \"double_quote\" : { \"color\" : \"brackethighlighter.quote\" }, \"regex\" : { \"color\" : \"brackethighlighter.quote\" } } } Then create an override .sublime-color-scheme file in Packages/User named <schme name to override>.sublime-color-scheme . Then add the scopes rules you are adding/overriding in the color scheme: { \"rules\" : [ { \"scope\" : \"brackethighlighter.default\" , \"foreground\" : \"#CC99CC\" }, { \"scope\" : \"brackethighlighter.unmatched\" , \"foreground\" : \"#F2777A\" }, { \"scope\" : \"brackethighlighter.curly\" , \"foreground\" : \"#CC99CC\" }, { \"scope\" : \"brackethighlighter.round\" , \"foreground\" : \"#FFCC66\" }, { \"scope\" : \"brackethighlighter.square\" , \"foreground\" : \"#6699CC\" }, { \"scope\" : \"brackethighlighter.angle\" , \"foreground\" : \"#F99157\" }, { \"scope\" : \"brackethighlighter.tag\" , \"foreground\" : \"#66CCCC\" }, { \"scope\" : \"brackethighlighter.c_define\" , \"foreground\" : \"#F99157\" }, { \"scope\" : \"brackethighlighter.quote\" , \"foreground\" : \"#99CC99\" } ] } Pre Sublime Color Scheme Example Assuming I was dissatisfied with using the built-in scopes for styling bracket highlighting and wanted to create my own scopes (and was on a Sublime build before 3152), this is how you would it. Override the bracket styles you want to apply a custom scope to (you can do some or all) by placing something similar in Packages/User/bh_core.sublime-settings : // Define region highlight styles { \"user_bracket_styles\" : { \"default\" : { \"color\" : \"brackethighlighter.default\" }, \"unmatched\" : { \"color\" : \"brackethighlighter.unmatched\" }, \"curly\" : { \"color\" : \"brackethighlighter.curly\" }, \"round\" : { \"color\" : \"brackethighlighter.round\" }, \"square\" : { \"color\" : \"brackethighlighter.square\" }, \"angle\" : { \"color\" : \"brackethighlighter.angle\" }, \"tag\" : { \"color\" : \"brackethighlighter.tag\" }, \"c_define\" : { \"color\" : \"brackethighlighter.c_define\" }, \"single_quote\" : { \"color\" : \"brackethighlighter.quote\" }, \"double_quote\" : { \"color\" : \"brackethighlighter.quote\" }, \"regex\" : { \"color\" : \"brackethighlighter.quote\" } } } Then you'd need to modify the existing tmTheme file you are using (or create a copy and modify that). Just add the new scope rules in the appropriate place in the PLIST ( real world example ). <dict> <key> name </key> <string> Bracket Tag </string> <key> scope </key> <string> brackethighlighter.tag </string> <key> settings </key> <dict> <key> foreground </key> <string> #66CCCC </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Curly </string> <key> scope </key> <string> brackethighlighter.curly </string> <key> settings </key> <dict> <key> foreground </key> <string> #CC99CC </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Round </string> <key> scope </key> <string> brackethighlighter.round </string> <key> settings </key> <dict> <key> foreground </key> <string> #FFCC66 </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Square </string> <key> scope </key> <string> brackethighlighter.square </string> <key> settings </key> <dict> <key> foreground </key> <string> #6699CC </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Angle </string> <key> scope </key> <string> brackethighlighter.angle </string> <key> settings </key> <dict> <key> foreground </key> <string> #F99157 </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Quote </string> <key> scope </key> <string> brackethighlighter.quote </string> <key> settings </key> <dict> <key> foreground </key> <string> #99CC99 </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Unmatched </string> <key> scope </key> <string> brackethighlighter.unmatched </string> <key> settings </key> <dict> <key> foreground </key> <string> #F2777A </string> </dict> </dict> Bracket Plugin API There are two kinds of plugins that can be written: definition plugins (plugins attached to bracket definitions via the plugin_library option). run instance plugins (plugins that are that are fed directly into the BracketHighligher command via the command parameter plugin ). Bracket plugins use BracketRegions . class BracketRegion ( begin_pt , end_pt ) BracketRegions are simple objects containing a begin pt and end pt of a bracket. Parameters : Parameter Description begin_pt Starting point. end_pt Ending point. Attributes : Attribute Description begin The start point of the BracketRegion . end The end point of the BracketRegion . Methods : def size ( self ) Returns size of region def move ( self , begin_pt , end_pt ) Returns a new BracketRegion object with the points moved to the specified position. Parameters : Parameter Description begin_pt Starting point. end_pt End Point. Returns : Return Description BracketRegion BracketRegion with new starting and ending points. def to_region ( self ) Converts BracketRegion to a SublimeRegion . Returns : Return Description SublimeRegion A Sublime Region. If needed, bracket plugins can be imported into each other in order to reuse functionality, but because they are not in Python's path, you need to use the special import method. def import_module ( module , attribute = None ) Imports a bh_plugin and returns the module or the module attribute if attribute is defined. Parameters : Parameter Description module The desired module to import. For internal plugins, they are referenced by bh_modules.<plugin name> . For custom plugins, you should use the folder path relative to Packages . So if I had a plugin called myplugin.py in my User/bh_modules folder, I would use User.bh_modules.myplugin . attribute The attribute to import from the module. Definition Plugins These are plugins that are attached to the bracket definition and aid in processing the brackets. These kinds of plugins have three methods you can provide: post_match , compare , and/or validate . validate def validate ( name , bracket , bracket_size , bfr ) validate is run before comparing the bracket to its corresponding opening or closing partner. This is used to perform additional validation on a found bracket. For example, lets say you have a bracket that is case sensitive. BH uses a case insensitive search, so with validate, you can ensure the originally found bracket matches the desired case. Parameters : Parameter Description name The name of the bracket definition being evaluated. bracket The bracket region being validated. bracket_side Opening (0) or closing (1) bracket. bfr The file buffer. Returns : Return Description Boolean Indicates whether the validation succeeded True or failed False . Example: Should match closing tag end but not match End case Foo of Guard1 -> ok ; Guard2 -> End end Example (from lowercase.py ): def validate ( name , bracket , bracket_side , bfr ): \"\"\"Check if bracket is lowercase.\"\"\" return bfr [ bracket . begin : bracket . end ] . islower () compare def compare ( name , first , second , bfr ) compare is run when comparing the opening bracket with the closing brackets. This allows you to provide logic to accept or reject the pairing of an opening bracket with a closing bracket. You should not change the text in the view during this operation. Parameters : Parameter Description name The name of the bracket definition being evaluated. first A bracket region for the opening bracket. second A bracket region for the closing bracket. bfr The file buffer. Returns : Return Description Boolean Indicating whether the the comparison yields a suitable match. Example (from phphekywords.py ): def compare ( name , first , second , bfr ): return \"end\" + bfr [ first . begin : first . end ] . lower () == bfr [ second . begin : second . end ] . lower () post_match def post_match ( name , style , first , second , center , bfr , threshold ) post_match is run after the brackets have been matched. You can do things like alter the highlighting region and change the bracket_style if needed. You should not change the text in the view during this operation. Parameters : Parameter Description name The name of the bracket definition being evaluated. style The style definition name that is to be used to highlight the region. first A bracket region for the opening bracket. second A bracket region for the closing bracket. center Position (point) of cursor (in retrospect, probably not the most intuitive name \u2013 not sure why I named it this). bfr The file buffer. threshold The calculated search window of the buffer that is being searched. Returns : Return Description BracketRegion Opening bracket region. BracketRegion Closing bracket region. style The name of the style definition to use. Example (from rubykeywords.py ): import re def post_match ( view , name , style , first , second , center , bfr , threshold ): if first is not None : # Strip whitespace from the beginning of first bracket open_bracket = bfr [ first . begin : first . end ] if open_bracket != \"do\" : m = re . match ( r \"^(\\s*\\b)[\\w\\W]*\" , open_bracket ) if m : first = first . move ( first . begin + m . end ( 1 ), first . end ) return first , second , style Example (snippet from tags.py ) def post_match ( view , name , style , first , second , center , bfr , threshold ): left , right = first , second threshold = [ 0 , len ( bfr )] if threshold is None else threshold tag_settings = sublime . load_settings ( \"bh_core.sublime-settings\" ) tag_mode = get_tag_mode ( view , tag_settings . get ( \"tag_mode\" , {})) tag_style = tag_settings . get ( \"tag_style\" , \"angle\" ) bracket_style = style if first is not None and tag_mode is not None : matcher = TagMatch ( view , bfr , threshold , first , second , center , tag_mode ) left , right = matcher . match () if not matcher . no_tag : bracket_style = tag_style return left , right , bracket_style highlighting def highlighting ( view , name , style , right ) highlighting is the last hook that gets run. This is at a point when BH no longer cares about what the actual bracket region is, so it is safe to modify it for highlighting purposes. The view really shouldn't be modified here. Parameters : Parameter Description view The current view containing brackets. name The name of the bracket definition being evaluated. style The style definition name that is to be used to highlight the region. left A bracket region for the opening bracket (could be None ). right A bracket region for the closing bracket (could be None ). Returns : Return Description BracketRegion Opening bracket region. BracketRegion Closing bracket region. Example (snippet from tags.py ) def highlighting ( view , name , style , left , right ): \"\"\" Highlight only the tag name. \"\"\" if style == \"tag\" : tag_name = '[\\w\\:\\.\\-]+' if left is not None : region = view . find ( tag_name , left . begin ) left = left . move ( region . begin (), region . end ()) if right is not None : region = view . find ( tag_name , right . begin ) right = right . move ( region . begin (), region . end ()) return left , right Run Instance Plugins Run instance plugins are manually invoked bracket matching with an attached plugin. The plugin itself is executed after a match is made. When defining a manually invoked BH command, either bh_key or bh_async_key should be used (key referring to key binding, but is also used for the menu and command palette). It may be misleading as to what bh_async_key means, but it is mainly a workaround to launch BH keys from the command palette. The command is kicked off asynchronously to ensure the palette closes before executing, but the BH command itself is still synchronous. Example of run instance plugin getting called: // Go to left bracket { \"caption\" : \"BracketHighlighter: Jump to Left Bracket\" , \"command\" : \"bh_key\" , \"args\" : { \"lines\" : true , \"plugin\" : { \"type\" : [ \"__all__\" ], \"command\" : \"bh_modules.bracketselect\" , \"args\" : { \"select\" : \"left\" } } } }, The args parameter is a dictionary. Parameter Description lines Show the number of lines between the matched brackets in the status bar. no_outside_adj This is a parameter used to tell the plugin to ignore the bracket_outside_adjacent setting. This is by default used for the bracketselect commands to ignore outside adjacent matching so it can do expanding selections or jump to parents brackets. The default is false when not defined, but it can be set to true or null in JSON (it would be None if defined directly in Python code). When null , the value will be read from ignore_outside_adjacent_in_plugin setting in the bh_core.sublime-settings file for convenient altering of the behavior. plugin Configuration for the plugin to be used. The plugin parameter is a dictionary that contains 3 arguments that define which plugin should get run, under which circumstance it is run, and with what parameters it is run with. Parameter Description type An array containing the bracket definition names that the plugin should be run on. Use __all__ for all bracket definitions. command The plugin to run. For internal plugins, they are referenced by bh_modules.<plugin name> . For custom plugins, you should use the folder path relative to Packages . So if I had a plugin called myplugin.py in my User/bh_modules folder, I would use User.bh_modules.myplugin . args A dictionary containing the arguments to feed into the plugin. You create run instance plugins by deriving a class from the BracketPluginCommand class. Then you provide a method called plugin that returns the class. class BracketPluginCommand () Attributes : Attribute Description view The sublime view containing the bracket (don't change this). left A bracket region for the opening bracket (can be changed). right A bracket region for the closing bracket (can be changed). selection An array containing the selection that triggered the match (can be changed). refresh_match A plugin can set this to true if the plugin has moved the cursor in such a way that the current highlighted match is no longer valid. This will cause BH to setup another match when idle. An example of this is in the bracketselect bh_plugin ; the cursor can be moved outside the matching brackets requiring a refresh to match the parent when the command is complete. nobracket This was added mainly for sub-bracket matching (a bracket inside other brackets like round brackets in quotes/strings). This is set to true if the plugin has caused both left and right brackets to be returned as None and it is not desired to fall back and match the parent. Methods : def run ( edit , name , < args > ) Parameters : Parameter Description edit The sublime edit object. name The bracket definition being evaluated. Example (from foldbracket.py ): import BracketHighlighter.bh_plugin as bh_plugin import sublime class FoldBrackets ( bh_plugin . BracketPluginCommand ): def run ( self , edit , name ): content = sublime . Region ( self . left . end , self . right . begin ) new_content = [ content ] if content . size () > 0 : if self . view . fold ( content ) == False : new_content = self . view . unfold ( content ) self . selection = new_content def plugin (): return FoldBrackets","title":"Customizing"},{"location":"customize/#customizing","text":"","title":"Customizing"},{"location":"customize/#overview","text":"BH is extremely flexible and can be customized and extended to fit a user's needs. The first step to customizing the existing rules and settings is to create a bh_core.sublime-settings in your User folder. With this file you can override any of the settings or bracket rules. By changing these settings, you can add support for new languages, or change the look of highlighting, and much more.","title":"Overview"},{"location":"customize/#core-visual-settings","text":"These are the settings related to the visual appearance of BH .","title":"Core Visual Settings"},{"location":"customize/#show_in_minimap","text":"Shows highlighted brackets in the minimap. This will work with all highlight styles except underline ; thin_underline has no issues. // Show brackets in the minimap. \"show_in_minimap\" : false ,","title":"show_in_minimap"},{"location":"customize/#show_unmatched","text":"Displays a special highlight for brackets that cannot be matched. // When only either the left or right bracket can be found // this defines if the unmatched bracket should be shown. \"show_unmatched\" : true ,","title":"show_unmatched"},{"location":"customize/#show_unmatched_exceptions","text":"List of languages in which the show_unmatched option logic will be reversed. // Do the opposite of \"show_unmatched\" for the languages listed below \"show_unmatched_exceptions\" : [],","title":"show_unmatched_exceptions"},{"location":"customize/#content_highlight_bar","text":"An experimental setting which can enable the display of a vertical bar that extends from the line containing the opening bracket to the line with the closing bracket. Takes a boolean of true or false . When align_content_highlight_bar is set to false , the bar will be shown on the first column regardless of indent level of the brackets. When align_content_highlight_bar is set to true , the bar will be aligned at the bracket indent level. // Experimental: Creates a visible bar at the beginning of all lines between // multiline bracket spans. \"content_highlight_bar\" : false ,","title":"content_highlight_bar"},{"location":"customize/#show_in_widgets","text":"An experimental setting that enables bracket highlighting in widgets (panels etc.). By default, BH does not highlight any brackets in plain text which is what the majority of the widget text boxes are. Regex search boxes are not plain text and should get bracket highlighting. // Experimental: Allow bracket highlighter to search in widgets. // Most widgets use Plain Text which BH should ignore, // But regex find views views are usually regular expression // Which should be the only views to trigger BH. \"search_in_widgets\" : false , Output panels are widgets as well, but sometimes the widget flag gets removed from them (Sublime issue). So this flag may or may not affect the output panel depending on its state. If you are a developer and wish to ensure an output panel that is created by your plugin does not have bracket highlighting, you can set the following setting to the view as True : bracket_highlighter.ignore .","title":"show_in_widgets"},{"location":"customize/#align_content_highlight_bar","text":"Modifies the behavior of content_highlight_bar and draws the vertical content bar at the indentation level of the highlighted bracket, but there are some limitations: The content bar cannot extend through an empty line unless the bar is on the first column. This is a limitation of the Sublime API. Empty lines will cause a gap in the bar. The content bar will not be shown on a line where non-whitespace characters cross the bar. // Experimental: Align the content highlight bar at the bracket indent level \"align_content_highlight_bar\" : false ,","title":"align_content_highlight_bar"},{"location":"customize/#high_visibility_enabled_by_default","text":"Enables high visibility mode by default. High visibility mode highlights not only the bracket but the content between as well, but it is disabled by default and must be toggled on to be used. This reverses the behavior and has it on by default. Takes a boolean true or false . // Enable high visibility by default when sublime starts up \"high_visibility_enabled_by_default\" : false ,","title":"high_visibility_enabled_by_default"},{"location":"customize/#high_visibility_style","text":"Modifies the styling of high visibility mode. The available options are solid , outline , underline , thin_underline , squiggly , and stippled . // High visibility style and color for high visibility mode \"high_visibility_style\" : \"outline\" ,","title":"high_visibility_style"},{"location":"customize/#high_visibility_color","text":"Modifies the high visibility color. There are three types of settings you can use: __default__ is a special reserved value which will use the color set in bracket_styles . See Configuring Highlight Style for more info. __bracket__ is a special reserved value which will inherit the defined color of the highlighted bracket. Any valid scope found in your color scheme. // Color for high visibility mode \"high_visibility_color\" : \"__bracket__\" ,","title":"high_visibility_color"},{"location":"customize/#behavioral-settings","text":"These settings affect the matching behavior.","title":"Behavioral Settings"},{"location":"customize/#match_only_adjacent","text":"Causes BH to only match and highlight brackets when the cursor is adjacent to a bracket. // Match brackets only when the cursor is touching the inside of the bracket \"match_only_adjacent\" : false ,","title":"match_only_adjacent"},{"location":"customize/#bracket_outside_adjacent","text":"Augments the matching behavior and will trigger matching when the cursor is adjacent to a cursor on the outside (not between the brackets). // Outside adjacent bracket matching \"bracket_outside_adjacent\" : true ,","title":"bracket_outside_adjacent"},{"location":"customize/#block_cursor_mode","text":"Experimental setting that modifies the bracket matching mode for block cursor. The bracket matching mode is one that makes a little more sense to some people in regards to the visual representation of block cursors. In this mode, brackets will match when the cursor is right before the bracket (or if using a block cursor, highlighting the character). So if you are someone that uses block cursors and find that toggling bracket_outside_adjacent still doesn't quite match brackets how you would like, you can give this setting a try. It has also been mentioned that this makes sense with Vim. When this setting is enabled, bracket_outside_adjacent will be ignored. // Experimental: Special matching mode for block cursor. // Essentially, this provides a matching mode that makes a little more // sense to some in regards to the visual representation of block cursors. // This will ignore \"bracket_outside_adjacent\". \"block_cursor_mode\" : false ,","title":"block_cursor_mode"},{"location":"customize/#ignore_outside_adjacent_in_plugin","text":"Ignores the bracket_outside_adjacent setting when running a plugin if the plugin sets no_outside_adj to null ( null for JSON or None in Python). // When \"bracket_outside_adjacet\" is set, and a plugin command explicitly sets // \"no_outside_adj\" \"None\" instead of \"true\" or the default \"false\", // this value will be used. \"ignore_outside_adjacent_in_plugin\" : true ,","title":"ignore_outside_adjacent_in_plugin"},{"location":"customize/#ignore_block_mode_in_plugin","text":"Experimental setting that ignores the block_cursor_mode setting when running a plugin if the plugin sets no_block_mode to null ( null for JSON or None in Python). // When \"block_cursor_mode\" is set, and a plugin command explicitly sets // \"no_block_mode\" to \"None\" instead of \"true\" or the default \"false\", // this value will be used. \"ignore_block_mode_in_plugin\" : true ,","title":"ignore_block_mode_in_plugin"},{"location":"customize/#bracket_string_escape_mode","text":"Depending on the setting, BH will either match sub-brackets inside strings with traditional string escape logic, or it will match sub-brackets in strings with regex escape logic. Takes a string value of either regex or string . // Set mode for string escapes to ignore (regex|string) \"bracket_string_escape_mode\" : \"string\" ,","title":"bracket_string_escape_mode"},{"location":"customize/#search_threshold","text":"Sets the search threshold. The search threshold determines how many characters BH will search through to find matching brackets before giving up. This setting only affects auto-matching and not on-demand calls from the command palette and menu. By default, this value is very conservative and can be increased. Keep in mind that a very large value may impact performance. // Character threshold to search \"search_threshold\" : 5000 ,","title":"search_threshold"},{"location":"customize/#ignore_threshold","text":"Causes the search_threshold limit to be ignored. It is not advised to use this as very large files may cause a noticeable performance hit, but has been made available due to a number of requests. // Ignore threshold \"ignore_threshold\" : false ,","title":"ignore_threshold"},{"location":"customize/#auto_selection_threshold","text":"A numerical value which controls the maximum number of simultaneous auto-matched brackets that are allowed. This setting will not be considered when running on-demand calls via the command palette or menu. // Set max number of multi-select brackets that will be searched automatically \"auto_selection_threshold\" : 10 ,","title":"auto_selection_threshold"},{"location":"customize/#kill_highlight_on_threshold","text":"Completely kills highlighting when auto_selection_threshold is exceeded. When disabled, BH will just highlight up to the threshold limit. // Enable this to completely kill highlighting if \"auto_selection_threshold\" // is exceeded. Default is to highlight up to the \"auto_selection_threshold\". \"kill_highlight_on_threshold\" : true ,","title":"kill_highlight_on_threshold"},{"location":"customize/#gutter_icons","text":"Globally enable or disable gutter icons. // Global control of gutter icons. \"gutter_icons\" : true ,","title":"gutter_icons"},{"location":"customize/#no_multi_select_icons","text":"Disables gutter icons when doing multiple selections. // Disable gutter icons when doing multi-select \"no_multi_select_icons\" : false ,","title":"no_multi_select_icons"},{"location":"customize/#popup-settings","text":"Settings related to the new popup hints when brackets are offscreen.","title":"Popup Settings"},{"location":"customize/#show_offscreen_bracket_popup","text":"Setting this will show a popup when the mouse hovers over a visible bracket and its matching pair is offscreen. The popup will show about 120 chars of context for every line shown. Additionally, if the offscreen bracket is located on a separate line, it will show an additional line(s) of context before and after. The context is shown in plain text, but the bracket will be emphasized by making the bracket bold and colorizing it with the your theme's keyword color. Character context , line context , and emphasis color can all be configured in the settings file. If a bracket was unmatched with an invalid highlight, you can mouse over it and will get the unmatched popup that explains the reasons why an unmatched bracket might occur. It also offers the option to attempt matching without the threshold. // Show hover popup // This will show a hover popup when mousing over // the visible bracket if the other // highlighted matching bracket is off screen. // It will show line text of the off screen bracket -/+ 128 chars // from the bracket start and end points. // A link will be available allowing the user to click and jump to // the other bracket. \"show_offscreen_bracket_popup\" : false ,","title":"show_offscreen_bracket_popup"},{"location":"customize/#show_bracket_popup_always","text":"If this setting is enabled with show_offscreen_bracket_popup , the bracket popup will always be shown on bracket hover, even if both brackets are onscreen. // If enabled with `show_offscreen_bracket_popup`,the popup will be shown // even if brackets are onscreen. \"show_bracket_popup_always\" : false ,","title":"show_bracket_popup_always"},{"location":"customize/#popup_char_context","text":"This determines the amount of characters per line of context that are allowed in the popup that is generated by show_offscreen_bracket_popup . By default, this setting is set to 120 . If you desire a different amount, you can specify it here. // Adjust char per line context of bracket popup. \"popup_char_context\" : 120 ,","title":"popup_char_context"},{"location":"customize/#popup_line_context","text":"Setting this determines the amount of additional lines of context that are allowed in the popup that is generated by show_offscreen_bracket_popup . popup_line_context is only applied to brackets that are not on the same line as the visible bracket. This value is split and half the lines will be gathered from before the line of interest and half from after the line of interest. It is recommend to use even numbers. Line context is a bit dynamic in the sense that if X number of lines cannot be gathered from before, the additional lines will be applied after; the inverse is true in regards to lines after. // Adjust number of lines of additional context // that are shown when brackets are vertically off screen. // Specified line count is split to context before and after the target line. // So a value of 4 would give you two lines of context before and two lines after. \"popup_line_context\" : 2 ,","title":"popup_line_context"},{"location":"customize/#use_custom_popup_bracket_emphasis","text":"This experimental setting allows you to override the default popup bracket emphasis which is calculated based on what scope/color you have assigned to the matched bracket style. With this setting enabled, you can use the setting popup_bracket_emphasis to control the color of the popup bracket emphasis. This will default to true if you don't have the MdPopups version which supports guessing the correct color. // Use 'popup_bracket_emphasis' to customize the popup's bracket emphasis color \"use_custom_popup_bracket_emphasis\" : false ,","title":"use_custom_popup_bracket_emphasis"},{"location":"customize/#popup_bracket_emphasis","text":"This setting dictates what color is used to emphasize the off screen bracket in the popup that is generated by show_offscreen_bracket_popup . Colors can either be specified by a standard TextMate scopes (the popup library being used is MdPopups, and it scans your theme for standard TextMate scopes and creates the necessary CSS for the popups), or you can specify a hex color in the form of #rgb or #rrggbb . Due to limitations in Sublime's HTML renderer, scopes that define background colors will most likely not show the background color. The default setting is #ff0000 . Outside of the scopes generated by MdPopups, it is likely that your theme may have additionally included scopes. Sublime seems to include these by default (but your mileage may vary): error deleted success inserted warning modified // Specify the scope (to get color) to emphasize the off screen bracket // in popups. Alternatively you can use a hex value in the form '#rgb' or '#rrggbb'. \"popup_bracket_emphasis\" : \"keyword\"","title":"popup_bracket_emphasis"},{"location":"customize/#special-settings","text":"","title":"Special Settings"},{"location":"customize/#debug","text":"Turn on debug logging. Set to true to enable or false to disable. //Debug logging \"debug_enable\" : false ,","title":"debug"},{"location":"customize/#tag-plugin-settings","text":"This section covers settings found in bh_tag.sublime-settings . All tag settings are dictionaries. Each key represents a tag mode such as: html , xhtml , cfml , etc. All of these are exposed so that even non-standard HTML syntax can be supported. Attention! More tag mode keys can be added, but they must be added to every setting with valid parameters.","title":"Tag Plugin Settings"},{"location":"customize/#tag_mode","text":"A list that contains a dictionary of different modes. Each mode tweaks the tag matching for the respective mode. Each entry in the list consists of a dictionary with the keys mode , syntax , and the optional first_line . mode specifies the mode name. syntax is a list of languages that are allowed in that mode. first_line (which is optional) is a regular expression that is applied to the first line in the file as a condition for selecting that mode. The tag_mode list is evaluated in order from top to bottom and selects the first entry that matches all the criteria. // Determine which style of tag-matching to use in which syntax. \"tag_mode\" : [ { \"mode\" : \"xml\" , \"syntax\" : [ \"XML\" ]}, { \"mode\" : \"xhtml\" , \"syntax\" : [ \"HTML\" , \"HTML 5\" , \"PHP\" , \"HTML (Jinja Templates)\" , \"HTML (Jinja2)\" , \"HTML (Rails)\" , \"HTML (Twig)\" , \"HTML (Django)\" , \"laravel-blade\" , \"blade\" , \"Handlebars\" , \"AngularJS\" , \"Java Server Pages (JSP)\" ], \"first_line\" : \"^[ \\\\t]*<\\\\?xml\" }, { \"mode\" : \"html\" , \"syntax\" : [ \"HTML\" , \"HTML 5\" , \"PHP\" , \"HTML (Jinja Templates)\" , \"HTML (Jinja2)\" , \"HTML (Rails)\" , \"HTML (Twig)\" , \"HTML (Django)\" , \"laravel-blade\" , \"blade\" , \"Handlebars\" , \"AngularJS\" , \"Java Server Pages (JSP)\" ] }, { \"mode\" : \"cfml\" , \"syntax\" : [ \"CFML\" , \"HTML+CFML\" , \"ColdFusion\" , \"ColdFusionCFC\" ] } ],","title":"tag_mode"},{"location":"customize/#tag_style","text":"Sets the highlight style for the tag plugin. The string value should correspond to a style entry in bracket_styles . See Configuring Highlight Style for more info. // Style to use for matched tags \"tag_style\" : { \"xhtml\" : \"tag\" , \"html\" : \"tag\" , \"cfml\" : \"tag\" },","title":"tag_style"},{"location":"customize/#tag_scope_exclude","text":"Excludes certain scopes from being evaluated when searching for tags. // Scopes to exclude from tag searches. \"tag_scope_exclude\" : { \"xhtml\" : [ \"string\" , \"comment\" ], \"html\" : [ \"string\" , \"comment\" ], \"cfml\" : [ \"string\" , \"comment\" ] },","title":"tag_scope_exclude"},{"location":"customize/#optional_tag_patterns","text":"Specifies a regex pattern for names that will be evaluated as optional tags. Optional tags are tags whose closing tag is optional. In the case of optional tags, you may only have an opening (with no self closing slash). null can be used to specify that there is no pattern for the specified tag mode. // Optional closing HTML tags. You can use 'null' if it does not require a pattern. \"optional_tag_patterns\" : { \"xml\" : null , \"xhtml\" : null , \"html\" : \"colgroup|dd|dt|li|options|p|td|tfoot|th|thead|tr\" , \"cfml\" : \"cf.+|colgroup|dd|dt|li|options|p|td|tfoot|th|thead|tr\" },","title":"optional_tag_patterns"},{"location":"customize/#void_tag_patterns","text":"Specifies a regex pattern for names that never have a closing tag. Void or empty tags can optionally use the self closing slash: <tag /> . null can be used to specify that there is no pattern for the specified tag mode. // Tags that never have a closing. You can use 'null' if it does not require a pattern. \"void_tag_patterns\" : { \"xml\" : null , \"xhtml\" : null , \"html\" : \"area|base|basefont|br|col|embed|frame|hr|img|input|isindex|keygen|link|meta|param|source|track|wbr\" , \"cfml\" : \"area|base|basefont|br|col|embed|frame|hr|img|input|isindex|keygen|link|meta|param|source|track|wbr\" },","title":"void_tag_patterns"},{"location":"customize/#self_closing_tag_patterns","text":"Specifies a regex pattern for tag names that can be represented in self closing form: <tag /> . null can be used to specify that there is no pattern for the specified tag mode. // Self closing tags. Single tags that are closed like this <tag /> \"self_closing_tag_patterns\" : { \"xml\" : \"[\\\\w:\\\\.\\\\-]+\" , \"xhtml\" : \"[\\\\w:\\\\.\\\\-]+\" , \"html\" : null , \"cfml\" : \"cf.+\" },","title":"self_closing_tag_patterns"},{"location":"customize/#tag_name","text":"Specifies the regex pattern for identifying the tag name for a given tag mode. This is broken out as a separate pattern because the Tag Attribute Select bh_plugin needs access to the tag name and tag attributes separate from the whole HTML tag regex. // Regex for tag name. Do not use capturing groups. \"tag_name\" : { \"xhtml\" : \"[\\\\w:\\\\.\\\\-]+\" , \"html\" : \"[\\\\w:\\\\.\\\\-]+\" , \"cfml\" : \"[\\\\w:\\\\.\\\\-]+\" },","title":"tag_name"},{"location":"customize/#attributes","text":"Specifies the regex pattern for identifying the tag attributes for a given tag mode. This is broken out as a separate pattern so that because the Tag Attribute Select bh_plugin needs access to the tag_name and tag attributes separate from the whole HTML tag regex. // HTML attributes. Do not use capturing groups. \"attributes\" : { \"xhtml\" : \"[\\\\w\\\\-:]+(?:\\\\s*=\\\\s*(?:\\\"(?:\\\\.|[^\\\"])*\\\"|'(?:\\\\.|[^'])*'))?\" , \"html\" : \"[\\\\w\\\\-:]+(?:\\\\s*=\\\\s*(?:\\\"[^\\\"]*\\\"|'[^']*'|[^\\\\s\\\"'`=<>]+))?\" , \"cfml\" : \"[\\\\w\\\\-\\\\.:]+(?:\\\\s*=\\\\s*(?:\\\"[^\\\"]*\\\"|'[^']*'|[^\\\\s\\\"'`=<>]+))?\" },","title":"attributes"},{"location":"customize/#start_tag","text":"Specifies the starting/opening tag regex. The pattern can accept the tag name and attribute portion of the pattern from the tag_name and attributes settings via the python string formatting variables tag_name and attributes (see example below). // Regex for start/opening tag. Use a capturing group for tag name and self closing indicator '/' only. // Attributes and tag names are inserted using python string formatting: // the keyword 'attributes' and `tag_name` are used. \"start_tag\" : { \"xhtml\" : \"<(%(tag_name)s)(?:\\\\s+%(attributes)s)*\\\\s*(/?)>\" , \"html\" : \"<(%(tag_name)s)(?:\\\\s+%(attributes)s)*\\\\s*(/?)>\" , \"cfml\" : \"<(%(tag_name)s)(?:(?:\\\\s+%(attributes)s)*|(?:(?<=cfif)|(?<=cfelseif))[^>]+)\\\\s*(/?)>\" },","title":"start_tag"},{"location":"customize/#end_tag","text":"Specifies the ending/closing tag regex. // Regex for end/closing tag. Only use a capturing group for name. \"end_tag\" : { \"xhtml\" : \"</([\\\\w\\\\:\\\\.\\\\-]+)[^>]*>\" , \"html\" : \"</([\\\\w\\\\:\\\\.\\\\-]+)[^>]*>\" , \"cfml\" : \"</([\\\\w\\\\:\\\\.\\\\-]+)[^>]*>\" }","title":"end_tag"},{"location":"customize/#swap-brackets-plugin-settings","text":"Swappable brackets for a given language can be defined in bh_swapping.sublime-settings . Swap rules are found under the key swapping where swapping is an array of language swap rules. \"swapping\" : [ { \"enabled\" : true , \"language_list\" : [ \"C++\" , \"C\" ], \"language_filter\" : \"allowlist\" , \"entries\" : [ { \"name\" : \"C/C++: #if\" , \"brackets\" : [ \"#if ${BH_SEL}\" , \"#endif\" ]}, { \"name\" : \"C/C++: #if, #else\" , \"brackets\" : [ \"#if${BH_SEL}\" , \"#else\\n${BH_TAB:/* CODE */}\\n#endif\" ]}, { \"name\" : \"C/C++: #if, #elif\" , \"brackets\" : [ \"#if${BH_SEL}\" , \"#elif ${BH_TAB:/* CONDITION */}\\n${BH_TAB:/* CODE */}\\n#endif\" ]}, { \"name\" : \"C/C++: #ifdef\" , \"brackets\" : [ \"#ifdef${BH_SEL}\" , \"#endif\" ]}, { \"name\" : \"C/C++: #ifdef, #else\" , \"brackets\" : [ \"#ifdef${BH_SEL}\" , \"#else\\n${BH_TAB:/* CODE */}\\n#endif\" ]}, { \"name\" : \"C/C++: #ifndef\" , \"brackets\" : [ \"#ifndef${BH_SEL}\" , \"#endif\" ]}, { \"name\" : \"C/C++: #ifndef, #else\" , \"brackets\" : [ \"#ifndef${BH_SEL}\" , \"#else\\n${BH_TAB:/* CODE */}\\n#endif\" ]} ] } ] Each language rule contains the following attributes: Attribute Type Description enabled bool Specifies if the rule is enabled. language_list [string] An array of languages. language_filter string A string that specifies whether the language_list is either a allowlist or blocklist . entries [dict] An array of dictionaries, where each dictionary describes a type of bracket that can be swapped to. The entries key is used to define the related bracket swap rules for the given language. Each entry represents a bracket you can swap to. Entry Type Description name string The name of the entry as it will be seen in the command palette. brackets [string] An array consisting of a string that represents the opening bracket and a string that represents the closing bracket. Within the brackets key, you can specify where the cursor(s) will appear by using ${BH_SEL} . If you would like the selection to display text as a hint to what a user should enter in the selection, you can use ${BH_SEL:optional text} . You can also define tab stops that a user can tab through and enter text. The tab stop syntax is ${BH_TAB} . You can also define optional text within a tab stop to give the user a hint of what should be entered using the following syntax: ${BH_TAB:optional text} .","title":"Swap Brackets Plugin Settings"},{"location":"customize/#wrap-brackets-plugin-settings","text":"Wrapping brackets for a given language can be defined in bh_wrapping.sublime-settings . Wrap rules are found under the key wrapping where wrapping is an array of language wrap rules. \"wrapping\" : [ { \"enabled\" : true , \"language_list\" : [ \"Plain text\" ], \"language_filter\" : \"blocklist\" , \"entries\" : [ { \"name\" : \"{} Curly\" , \"brackets\" : [ \"{\" , \"}${BH_SEL}\" ], \"insert_style\" : [ \"inline\" , \"block\" , \"indent_block\" ]} ] } ] Each language rule contains the following attributes: Attribute Type Description enabled bool Specifies if the rule is enabled. language_list [string] An array of languages. language_filter string A string that specifies if the language_list is either a allowlist or blocklist . entries [dict] An array of dictionaries, where each dictionary describes a type of bracket that can be used to wrap the selection. The entries key is used to define the related bracket wrap rules for the given language. Each entry represents a bracket you can wrap the selection with. Entry Type Description name string The name of the entry as it will be seen in the command palette. brackets [string] An array consisting of a string that represents the opening bracket and a string that represents the closing bracket. insert_style [string] An array consisting of allowed insertion styles. Allowed insertion styles are: inline , block , and indent_block . Default is [ 'inline' ] . Within the brackets key, you can specify where the cursor(s) will appear by using ${BH_SEL} . If you would like the selection to display text as a hint to what a user should enter in the selection, you can use ${BH_SEL:optional text} . You can also define tab stops that a user can tab through and enter text. The tab stop syntax is ${BH_TAB} . You can also define optional text within a tab stop to give the user a hint of what should be entered using the following syntax: ${BH_TAB:optional text} .","title":"Wrap Brackets Plugin Settings"},{"location":"customize/#configuring-brackets","text":"BH has been written to allow users the ability to define any bracket they would like to have highlighted. Bracket rules are defined with case insensitive regular expressions, syntax scoping, and bh_plugins . There are two kinds of brackets you can define. scope_brackets which search the file for scope regions and then use regex to test for opening and closing brackets. brackets which use regex to find opening and closing brackets. The brackets rules should usually be the preferred type. scope_brackets are usually used for brackets whose opening and closing are the same. These type are not easily distinguishable from one another by regex. Scope brackets must be contained in a continuous scope region like string for quotes etc. BH uses a wrapper around Python's re regex library to add support for additional back references. See the Extended Regex Guide . Tip Brackets can be modified, or even added, without copying the entire bracket rule list to the user settings. See Bracket Rule Management for more info.","title":"Configuring Brackets"},{"location":"customize/#configuring-brackets-rules","text":"Brackets are defined under brackets in bh_core.sublime-settings . angle and curly brackets will be used as an example (not all options may be shown in these examples): { \"name\" : \"angle\" , \"open\" : \"(<)\" , \"close\" : \"(>)\" , \"style\" : \"angle\" , \"scope_exclude\" : [ \"string\" , \"comment\" , \"keyword.operator\" ], \"language_filter\" : \"allowlist\" , \"language_list\" : [ \"HTML\" , \"HTML 5\" , \"XML\" , \"PHP\" , \"CFML\" , \"HTML+CFML\" , \"ColdFusion\" , \"ColdFusionCFC\" ], \"plugin_library\" : \"bh_modules.tags\" , \"enabled\" : true }, { \"name\" : \"curly\" , \"open\" : \"(\\\\{)\" , \"close\" : \"(\\\\})\" , \"style\" : \"curly\" , \"scope_exclude\" : [ \"string\" , \"comment\" ], \"scope_exclude_exceptions\" : [ \"string.other.math.block.environment.latex\" ], \"language_filter\" : \"blocklist\" , \"language_list\" : [ \"Plain text\" ], \"find_in_sub_search\" : \"true\" , \"ignore_string_escape\" : true , \"enabled\" : true }, Parameter Description name The name of the bracket (should be unique). open Defines the opening bracket (one and only one capturing group must be present). close Defines the closing bracket (one and only one capturing group must be present). style Name of the style definition to be used to highlight the brackets. See Configuring Bracket Styles for more info. scope_exclude Scopes where the opening and closing brackets should be ignored. language_filter This works in conjunction with language_list . It specifies whether language_list is a blocklist or allowlist . language_list An array of tmLanguage file names that should be avoided or included for highlighting. Looks to language_filter to determine if avoidance or inclusion is used. enabled Disable or enable rule. scope_exclude_exceptions (optional) Used to ignore excluding of sub scopes such as in the curly example above where string is excluded, but not string.other.math.block.environment.latex . plugin_library (optional) Defines a plugin to use for determining matches (see Bracket Plugin API for more info on matching plugins). find_in_sub_search (optional) This rule should be included when doing sub bracket matching in scope_brackets (like finding round brackets between quotes etc.). The setting must be a string and can be either true , false , or only ; only means this bracket is only matched as a sub bracket of a scope_bracket . ignore_string_escape (optional) Do not ignore sub brackets found in strings and regex when escaped, but use internal escape logic to determine if the brackets should be ignored based on whether regex or string escape mode is set.","title":"Configuring Brackets Rules"},{"location":"customize/#configuring-scope-brackets-rules","text":"Scope Brackets are defined under scope_brackets in bh_core.sublime-settings . py_single_quote bracket will be used as an example (not all options are shown in this example): { \"name\" : \"py_single_quote\" , \"open\" : \"u?r?((?:'')?')\" , \"close\" : \"((?:'')?')\" , \"style\" : \"single_quote\" , \"scopes\" : [ \"string\" ], \"language_filter\" : \"allowlist\" , \"language_list\" : [ \"Python\" ], \"sub_bracket_search\" : \"true\" , \"enabled\" : true }, Parameters Description name The name of the bracket (should be unique). open Defines the opening bracket (one and only one capturing group must be present). close Defines the closing bracket (one and only one capturing group must be present). style Name of the style definition to be used to highlight the brackets. See Configuring Bracket Styles for more info. scopes Scope that should be searched to find the opening and closing brackets. language_filter This works in conjunction with language_list . It specifies whether language_list is a blocklist or allowlist . language_list An array of tmLanguage file names that should be avoided or included for highlighting. Looks to language_filter to determine if avoidance or inclusion is used. sub_bracket_search Specifies whether this scope bracket also searches for sub brackets (like curly brackets in strings etc.). enabled Disable or enable rule. plugin_library (optional) Defines plugin to use for determining matches (see Bracket Plugin API for more info on matching plugins).","title":"Configuring Scope Brackets Rules"},{"location":"customize/#bracket-rule-management","text":"In the past, BracketHighlighter required a user to copy the entire bracket list to the user bh_core.sublime-settings file. This was a cumbersome requirement that also punished a user because if they did this, they wouldn't automatically get updates to the rules as all the rules were now overridden by the user's settings file. BracketHighlighter now lets you add or modify existing rules without overriding the entire rule set, or even the entire target rule. Let's say you have a custom language you want to have on your machine. Now, you can simply add it to one of the two settings arrays: \"user_scope_brackets\" and \"user_brackets\": \"user_scope_brackets\" : [], \"user_brackets\" : [ { \"name\" : \"mylang\" , \"open\" : \"^\\\\s*\\\\b(if|subr|bytemap|enum|command|for|while|macro|do)\\\\b\" , \"close\" : \"\\\\b(e(?:if|subr|bytemap|enum|command|for|while|macro)|until)\\\\b\" , \"style\" : \"default\" , \"scope_exclude\" : [ \"string\" , \"comment\" ], \"plugin_library\" : \"User.bh_modules.mylangkeywords\" , \"language_filter\" : \"allowlist\" , \"language_list\" : [ \"mylang\" ], \"enabled\" : true } ], Let's say you want to modify an existing rule, maybe just tweak the language list. All you have to do is use the same name of the item you want to change. Only that attribute will be overridden: \"user_brackets\" : [ // Angle { \"name\" : \"angle\" , \"language_list\" : [ \"HTML\" , \"HTML 5\" , \"XML\" , \"PHP\" , \"HTML (Rails)\" , \"HTML (Jinja Templates)\" , \"HTML (Jinja2)\" , \"HTML (Twig)\" , \"CFML\" , \"HTML+CFML\" , \"ColdFusion\" , \"ColdFusionCFC\" , \"laravel-blade\" , \"Handlebars\" , \"AngularJS\" , \"SomeNewLanguage\" // <--- New language ] } ], Let's say you want to insert a new rule between two rules. You can turn on debug mode and call the BracketHighlighter: (Debug) Filter Rules by Key , and then select position to see the current rule order and their position index. To turn on Debug mode, just add \"debug_enable\" : true to your user settings file. Example of BracketHighlighter: (Debug) Filter Rules by Key output: [ [ { \"name\" : \"curly\" , \"position\" : 0 }, { \"name\" : \"round\" , \"position\" : 1 }, { \"name\" : \"square\" , \"position\" : 2 }, { \"name\" : \"html\" , \"position\" : 3 }, { \"name\" : \"cfml\" , \"position\" : 4 }, { \"name\" : \"php_angle\" , \"position\" : 5 }, { \"name\" : \"angle\" , \"position\" : 6 }, { \"name\" : \"cssedit_groups\" , \"position\" : 7 }, { \"name\" : \"ruby_embedded_html\" , \"position\" : 8 }, { \"name\" : \"ruby\" , \"position\" : 9 }, { \"name\" : \"c_compile_switch\" , \"position\" : 10 }, { \"name\" : \"php_keywords\" , \"position\" : 11 }, { \"name\" : \"erlang\" , \"position\" : 12 }, { \"name\" : \"bash\" , \"position\" : 13 }, { \"name\" : \"fish\" , \"position\" : 14 }, { \"name\" : \"mylang\" , \"position\" : 15 } ], [ { \"name\" : \"py_single_quote\" , \"position\" : 0 }, { \"name\" : \"py_double_quote\" , \"position\" : 1 }, { \"name\" : \"single_quote\" , \"position\" : 2 }, { \"name\" : \"double_quote\" , \"position\" : 3 }, { \"name\" : \"jsregex\" , \"position\" : 4 }, { \"name\" : \"perlregex\" , \"position\" : 5 }, { \"name\" : \"rubyregex\" , \"position\" : 6 }, { \"name\" : \"mditalic\" , \"position\" : 7 }, { \"name\" : \"mdbold\" , \"position\" : 8 } ] ] Then you can specify the position you want to insert at using the position key: \"user_scope_brackets\" : [], \"user_brackets\" : [ { \"name\" : \"mylang\" , \"position\" : 4 , // <-- New position \"open\" : \"^\\\\s*\\\\b(if|subr|bytemap|enum|command|for|while|macro|do)\\\\b\" , \"close\" : \"\\\\b(e(?:if|subr|bytemap|enum|command|for|while|macro)|until)\\\\b\" , \"style\" : \"default\" , \"scope_exclude\" : [ \"string\" , \"comment\" ], \"plugin_library\" : \"User.bh_modules.mylangkeywords\" , \"language_filter\" : \"allowlist\" , \"language_list\" : [ \"mylang\" ], \"enabled\" : true } ], And if you run the debug command again, you will see that the position has changed: { \"name\" : \"curly\" , \"position\" : 0 }, { \"name\" : \"round\" , \"position\" : 1 }, { \"name\" : \"square\" , \"position\" : 2 }, { \"name\" : \"html\" , \"position\" : 3 }, { \"name\" : \"mylang\" , \"position\" : 4 }, // <-- New position { \"name\" : \"cfml\" , \"position\" : 5 }, { \"name\" : \"php_angle\" , \"position\" : 6 }, This can be used to adjust the position of default rules from your user settings as seen in the overrides above. So, unless you are forking BH to pull request a change to the default rules, you can now modify the rules in just these two settings without copying or touching the default rules. This will allow you to make changes, but still receive new updated rules. \"user_scope_brackets\" : [], \"user_brackets\" : [],","title":"Bracket Rule Management"},{"location":"customize/#configuring-highlight-style","text":"Each bracket definition (described in Configuring Scope Brackets and Configuring Brackets ) has a style option that you can assign a specific style to. The name of the style corresponds to a style definition. Style definitions are defined under bracket_styles in bh_core.sublime-settings . Normally you would override the existing style or add new styles through the user_bracket_styles instead of editing bracket_styles directly; direct editing of bracket_styles is mainly reserved for providing defaults to a user. You can add and remove as many styles as you wish, but there are two special style definitions whose names are reserved: default and unmatched . If your remove them, they will be added back automatically in memory, but you can configure them. All styles, even the reserved styles, follow the same format. See description below: // Define region highlight styles \"bracket_styles\" : { \"default\" : { \"icon\" : \"dot\" , \"color\" : \"region.yellowish brackethighlighter.default\" , \"style\" : \"underline\" }, // This particular style is used to highlight // unmatched bracket pairs. It is a special // style. \"unmatched\" : { \"icon\" : \"question\" , \"color\" : \"region.redish\" , \"style\" : \"outline\" }, // User defined region styles \"curly\" : { \"icon\" : \"curly_bracket\" , // \"color\": \"region.purplish\" // \"style\": \"underline\" } } Parameter Description icon Icon to show in gutter. Available options are: angle , round , curly , square , tag , star , dot , bookmark , question , quote , double_quote , single_quote , single_quote_offset , double_quote_offset , none . color Scope to use that defines the color. style Highlight style. Available options are: solid , outline , underline , none . ST3 has additional styles: thin_underline , squiggly , stippled . endpoint Boolean to highlight just the beginning and end of bracket. This is useful for things like tags where it may be distracting highlighting the entire tag. As shown in the example above, an option can be omitted. If an option is omitted it will use the corresponding option in default . If for some reason you've modified default to not have all options, an internal default will be used. So curly , in this example, defines icon , but will use the default definition's color and style . Clearing Up Color Misconceptions Often I am asked why you can't just add a color directly like \"color\" : \"#D04321\" . This is not a decision made by me, but is a limitation of the Sublime API, specifically with region coloring, which is what BH uses to highlight brackets. Sublime needs a scope that exists in your color scheme file. It finds the rule regarding that scope, and applies the color specified in that rule. Around Sublime build 3148, region-ish colors were added. These are scopes that get auto-generated for a color scheme (but can also be explicitly defined) that are meant to define a way for users to pick a specific color that corresponds to the color palette of the theme: region.redish , region.orangish , region.yellowish , region.greenish , region.bluish , region.purplish , and region.pinkish . BH by default uses these now in the color scheme where before it defined nothing, so if you are on Sublime 3148+, you should see colors. If the color scheme creator has not explicitly defined a region-ish color for all the default region-ish colors, Sublime will guess a color that is close. If the palette of the color scheme is limited, you may get colors that don't make sense or situations where the same color is picked for colors that are close to begin with \u2013 like region.purplish and region.pinkish .","title":"Configuring Highlight Style"},{"location":"customize/#example-adding-and-overriding-styles","text":"To customize a color, style, or icon, you can simply override that specific style definition by placing your override in user_bracket_styles in your Packages/User/bh_core.sublime-settings file. You are also free to add new styles as well. Just and the key name you want to add/override and specify the options you want to explicitly define, and those specific options will override the existing rule or the defaults. In this example, we will override the exiting curly and only change the color. We will continue to use the icon and style defined defined in the exiting curly rule. We've used the region-ish color region.bluish (for Sublime 3148+) to use the closes color Sublime can find to blue in the existing color scheme. We could have also used any other scope that the color scheme already has rules for. \"user_bracket_styles\" : { \"curly\" : { \"color\" : \"region.bluish\" } } If curly had not already been defined, curly would have been added to the existing rules and any options that were not specified would have inherited their value from the reserved default rule.","title":"Example: Adding and Overriding Styles"},{"location":"customize/#example-specifying-custom-colors-in-schemes","text":"If you are unsatisfied or unable to use region-ish colors, and are not satisfied with existing scope and color rules in your color scheme, you can modify your color scheme and add the scope and color you wish to use. In Sublime 3152+, you can use the new color format to create an override color scheme instead of directly editing your color scheme. To append your new rule (or override an existing rule) you can create a .sublime-color-scheme file in your Packages/User folder. You only need to specify the colors you are explicitly adding or overriding. In this case, the scheme file would only contain the new scopes we want to append to the base color scheme file. In this case we are adding our own custom region called brackethighligher.curly and assigning a color of #CC99CC . { \"rules\" : [ { \"scope\" : \"brackethighlighter.curly\" , \"foreground\" : \"#CC99CC\" } ] } And now we can use our new scope: \"user_bracket_styles\" : { \"curly\" : { \"icon\" : \"curly_bracket\" \"color\" : \"brackethighlighter.curly\" , // \"style\": \"underline\" } } For Sublime builds <3152, you'd have to actually modify the existing color scheme ( tmTheme ) file that you are using and add your specific scope definition: <dict> <key> name </key> <string> Bracket Curly </string> <key> scope </key> <string> brackethighlighter.curly </string> <key> settings </key> <dict> <key> foreground </key> <string> #CC99CC </string> </dict> </dict> Sublime Color Scheme Example Assuming I was dissatisfied with using the built-in region-ish colors and wanted to create my own scopes (and was on a Sublime build that supports .sublime-color-scheme files), this is how you would it. Override the bracket styles you want to apply a custom scope to (you can do some or all) by placing something similar in Packages/User/bh_core.sublime-settings : // Define region highlight styles { \"user_bracket_styles\" : { \"default\" : { \"color\" : \"brackethighlighter.default\" }, \"unmatched\" : { \"color\" : \"brackethighlighter.unmatched\" }, \"curly\" : { \"color\" : \"brackethighlighter.curly\" }, \"round\" : { \"color\" : \"brackethighlighter.round\" }, \"square\" : { \"color\" : \"brackethighlighter.square\" }, \"angle\" : { \"color\" : \"brackethighlighter.angle\" }, \"tag\" : { \"color\" : \"brackethighlighter.tag\" }, \"c_define\" : { \"color\" : \"brackethighlighter.c_define\" }, \"single_quote\" : { \"color\" : \"brackethighlighter.quote\" }, \"double_quote\" : { \"color\" : \"brackethighlighter.quote\" }, \"regex\" : { \"color\" : \"brackethighlighter.quote\" } } } Then create an override .sublime-color-scheme file in Packages/User named <schme name to override>.sublime-color-scheme . Then add the scopes rules you are adding/overriding in the color scheme: { \"rules\" : [ { \"scope\" : \"brackethighlighter.default\" , \"foreground\" : \"#CC99CC\" }, { \"scope\" : \"brackethighlighter.unmatched\" , \"foreground\" : \"#F2777A\" }, { \"scope\" : \"brackethighlighter.curly\" , \"foreground\" : \"#CC99CC\" }, { \"scope\" : \"brackethighlighter.round\" , \"foreground\" : \"#FFCC66\" }, { \"scope\" : \"brackethighlighter.square\" , \"foreground\" : \"#6699CC\" }, { \"scope\" : \"brackethighlighter.angle\" , \"foreground\" : \"#F99157\" }, { \"scope\" : \"brackethighlighter.tag\" , \"foreground\" : \"#66CCCC\" }, { \"scope\" : \"brackethighlighter.c_define\" , \"foreground\" : \"#F99157\" }, { \"scope\" : \"brackethighlighter.quote\" , \"foreground\" : \"#99CC99\" } ] } Pre Sublime Color Scheme Example Assuming I was dissatisfied with using the built-in scopes for styling bracket highlighting and wanted to create my own scopes (and was on a Sublime build before 3152), this is how you would it. Override the bracket styles you want to apply a custom scope to (you can do some or all) by placing something similar in Packages/User/bh_core.sublime-settings : // Define region highlight styles { \"user_bracket_styles\" : { \"default\" : { \"color\" : \"brackethighlighter.default\" }, \"unmatched\" : { \"color\" : \"brackethighlighter.unmatched\" }, \"curly\" : { \"color\" : \"brackethighlighter.curly\" }, \"round\" : { \"color\" : \"brackethighlighter.round\" }, \"square\" : { \"color\" : \"brackethighlighter.square\" }, \"angle\" : { \"color\" : \"brackethighlighter.angle\" }, \"tag\" : { \"color\" : \"brackethighlighter.tag\" }, \"c_define\" : { \"color\" : \"brackethighlighter.c_define\" }, \"single_quote\" : { \"color\" : \"brackethighlighter.quote\" }, \"double_quote\" : { \"color\" : \"brackethighlighter.quote\" }, \"regex\" : { \"color\" : \"brackethighlighter.quote\" } } } Then you'd need to modify the existing tmTheme file you are using (or create a copy and modify that). Just add the new scope rules in the appropriate place in the PLIST ( real world example ). <dict> <key> name </key> <string> Bracket Tag </string> <key> scope </key> <string> brackethighlighter.tag </string> <key> settings </key> <dict> <key> foreground </key> <string> #66CCCC </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Curly </string> <key> scope </key> <string> brackethighlighter.curly </string> <key> settings </key> <dict> <key> foreground </key> <string> #CC99CC </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Round </string> <key> scope </key> <string> brackethighlighter.round </string> <key> settings </key> <dict> <key> foreground </key> <string> #FFCC66 </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Square </string> <key> scope </key> <string> brackethighlighter.square </string> <key> settings </key> <dict> <key> foreground </key> <string> #6699CC </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Angle </string> <key> scope </key> <string> brackethighlighter.angle </string> <key> settings </key> <dict> <key> foreground </key> <string> #F99157 </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Quote </string> <key> scope </key> <string> brackethighlighter.quote </string> <key> settings </key> <dict> <key> foreground </key> <string> #99CC99 </string> </dict> </dict> <dict> <key> name </key> <string> Bracket Unmatched </string> <key> scope </key> <string> brackethighlighter.unmatched </string> <key> settings </key> <dict> <key> foreground </key> <string> #F2777A </string> </dict> </dict>","title":"Example: Specifying Custom Colors in Schemes"},{"location":"customize/#bracket-plugin-api","text":"There are two kinds of plugins that can be written: definition plugins (plugins attached to bracket definitions via the plugin_library option). run instance plugins (plugins that are that are fed directly into the BracketHighligher command via the command parameter plugin ). Bracket plugins use BracketRegions . class BracketRegion ( begin_pt , end_pt ) BracketRegions are simple objects containing a begin pt and end pt of a bracket. Parameters : Parameter Description begin_pt Starting point. end_pt Ending point. Attributes : Attribute Description begin The start point of the BracketRegion . end The end point of the BracketRegion . Methods : def size ( self ) Returns size of region def move ( self , begin_pt , end_pt ) Returns a new BracketRegion object with the points moved to the specified position. Parameters : Parameter Description begin_pt Starting point. end_pt End Point. Returns : Return Description BracketRegion BracketRegion with new starting and ending points. def to_region ( self ) Converts BracketRegion to a SublimeRegion . Returns : Return Description SublimeRegion A Sublime Region. If needed, bracket plugins can be imported into each other in order to reuse functionality, but because they are not in Python's path, you need to use the special import method. def import_module ( module , attribute = None ) Imports a bh_plugin and returns the module or the module attribute if attribute is defined. Parameters : Parameter Description module The desired module to import. For internal plugins, they are referenced by bh_modules.<plugin name> . For custom plugins, you should use the folder path relative to Packages . So if I had a plugin called myplugin.py in my User/bh_modules folder, I would use User.bh_modules.myplugin . attribute The attribute to import from the module.","title":"Bracket Plugin API"},{"location":"customize/#definition-plugins","text":"These are plugins that are attached to the bracket definition and aid in processing the brackets. These kinds of plugins have three methods you can provide: post_match , compare , and/or validate .","title":"Definition Plugins"},{"location":"customize/#validate","text":"def validate ( name , bracket , bracket_size , bfr ) validate is run before comparing the bracket to its corresponding opening or closing partner. This is used to perform additional validation on a found bracket. For example, lets say you have a bracket that is case sensitive. BH uses a case insensitive search, so with validate, you can ensure the originally found bracket matches the desired case. Parameters : Parameter Description name The name of the bracket definition being evaluated. bracket The bracket region being validated. bracket_side Opening (0) or closing (1) bracket. bfr The file buffer. Returns : Return Description Boolean Indicates whether the validation succeeded True or failed False . Example: Should match closing tag end but not match End case Foo of Guard1 -> ok ; Guard2 -> End end Example (from lowercase.py ): def validate ( name , bracket , bracket_side , bfr ): \"\"\"Check if bracket is lowercase.\"\"\" return bfr [ bracket . begin : bracket . end ] . islower ()","title":"validate"},{"location":"customize/#compare","text":"def compare ( name , first , second , bfr ) compare is run when comparing the opening bracket with the closing brackets. This allows you to provide logic to accept or reject the pairing of an opening bracket with a closing bracket. You should not change the text in the view during this operation. Parameters : Parameter Description name The name of the bracket definition being evaluated. first A bracket region for the opening bracket. second A bracket region for the closing bracket. bfr The file buffer. Returns : Return Description Boolean Indicating whether the the comparison yields a suitable match. Example (from phphekywords.py ): def compare ( name , first , second , bfr ): return \"end\" + bfr [ first . begin : first . end ] . lower () == bfr [ second . begin : second . end ] . lower ()","title":"compare"},{"location":"customize/#post_match","text":"def post_match ( name , style , first , second , center , bfr , threshold ) post_match is run after the brackets have been matched. You can do things like alter the highlighting region and change the bracket_style if needed. You should not change the text in the view during this operation. Parameters : Parameter Description name The name of the bracket definition being evaluated. style The style definition name that is to be used to highlight the region. first A bracket region for the opening bracket. second A bracket region for the closing bracket. center Position (point) of cursor (in retrospect, probably not the most intuitive name \u2013 not sure why I named it this). bfr The file buffer. threshold The calculated search window of the buffer that is being searched. Returns : Return Description BracketRegion Opening bracket region. BracketRegion Closing bracket region. style The name of the style definition to use. Example (from rubykeywords.py ): import re def post_match ( view , name , style , first , second , center , bfr , threshold ): if first is not None : # Strip whitespace from the beginning of first bracket open_bracket = bfr [ first . begin : first . end ] if open_bracket != \"do\" : m = re . match ( r \"^(\\s*\\b)[\\w\\W]*\" , open_bracket ) if m : first = first . move ( first . begin + m . end ( 1 ), first . end ) return first , second , style Example (snippet from tags.py ) def post_match ( view , name , style , first , second , center , bfr , threshold ): left , right = first , second threshold = [ 0 , len ( bfr )] if threshold is None else threshold tag_settings = sublime . load_settings ( \"bh_core.sublime-settings\" ) tag_mode = get_tag_mode ( view , tag_settings . get ( \"tag_mode\" , {})) tag_style = tag_settings . get ( \"tag_style\" , \"angle\" ) bracket_style = style if first is not None and tag_mode is not None : matcher = TagMatch ( view , bfr , threshold , first , second , center , tag_mode ) left , right = matcher . match () if not matcher . no_tag : bracket_style = tag_style return left , right , bracket_style","title":"post_match"},{"location":"customize/#highlighting","text":"def highlighting ( view , name , style , right ) highlighting is the last hook that gets run. This is at a point when BH no longer cares about what the actual bracket region is, so it is safe to modify it for highlighting purposes. The view really shouldn't be modified here. Parameters : Parameter Description view The current view containing brackets. name The name of the bracket definition being evaluated. style The style definition name that is to be used to highlight the region. left A bracket region for the opening bracket (could be None ). right A bracket region for the closing bracket (could be None ). Returns : Return Description BracketRegion Opening bracket region. BracketRegion Closing bracket region. Example (snippet from tags.py ) def highlighting ( view , name , style , left , right ): \"\"\" Highlight only the tag name. \"\"\" if style == \"tag\" : tag_name = '[\\w\\:\\.\\-]+' if left is not None : region = view . find ( tag_name , left . begin ) left = left . move ( region . begin (), region . end ()) if right is not None : region = view . find ( tag_name , right . begin ) right = right . move ( region . begin (), region . end ()) return left , right","title":"highlighting"},{"location":"customize/#run-instance-plugins","text":"Run instance plugins are manually invoked bracket matching with an attached plugin. The plugin itself is executed after a match is made. When defining a manually invoked BH command, either bh_key or bh_async_key should be used (key referring to key binding, but is also used for the menu and command palette). It may be misleading as to what bh_async_key means, but it is mainly a workaround to launch BH keys from the command palette. The command is kicked off asynchronously to ensure the palette closes before executing, but the BH command itself is still synchronous. Example of run instance plugin getting called: // Go to left bracket { \"caption\" : \"BracketHighlighter: Jump to Left Bracket\" , \"command\" : \"bh_key\" , \"args\" : { \"lines\" : true , \"plugin\" : { \"type\" : [ \"__all__\" ], \"command\" : \"bh_modules.bracketselect\" , \"args\" : { \"select\" : \"left\" } } } }, The args parameter is a dictionary. Parameter Description lines Show the number of lines between the matched brackets in the status bar. no_outside_adj This is a parameter used to tell the plugin to ignore the bracket_outside_adjacent setting. This is by default used for the bracketselect commands to ignore outside adjacent matching so it can do expanding selections or jump to parents brackets. The default is false when not defined, but it can be set to true or null in JSON (it would be None if defined directly in Python code). When null , the value will be read from ignore_outside_adjacent_in_plugin setting in the bh_core.sublime-settings file for convenient altering of the behavior. plugin Configuration for the plugin to be used. The plugin parameter is a dictionary that contains 3 arguments that define which plugin should get run, under which circumstance it is run, and with what parameters it is run with. Parameter Description type An array containing the bracket definition names that the plugin should be run on. Use __all__ for all bracket definitions. command The plugin to run. For internal plugins, they are referenced by bh_modules.<plugin name> . For custom plugins, you should use the folder path relative to Packages . So if I had a plugin called myplugin.py in my User/bh_modules folder, I would use User.bh_modules.myplugin . args A dictionary containing the arguments to feed into the plugin. You create run instance plugins by deriving a class from the BracketPluginCommand class. Then you provide a method called plugin that returns the class. class BracketPluginCommand () Attributes : Attribute Description view The sublime view containing the bracket (don't change this). left A bracket region for the opening bracket (can be changed). right A bracket region for the closing bracket (can be changed). selection An array containing the selection that triggered the match (can be changed). refresh_match A plugin can set this to true if the plugin has moved the cursor in such a way that the current highlighted match is no longer valid. This will cause BH to setup another match when idle. An example of this is in the bracketselect bh_plugin ; the cursor can be moved outside the matching brackets requiring a refresh to match the parent when the command is complete. nobracket This was added mainly for sub-bracket matching (a bracket inside other brackets like round brackets in quotes/strings). This is set to true if the plugin has caused both left and right brackets to be returned as None and it is not desired to fall back and match the parent. Methods : def run ( edit , name , < args > ) Parameters : Parameter Description edit The sublime edit object. name The bracket definition being evaluated. Example (from foldbracket.py ): import BracketHighlighter.bh_plugin as bh_plugin import sublime class FoldBrackets ( bh_plugin . BracketPluginCommand ): def run ( self , edit , name ): content = sublime . Region ( self . left . end , self . right . begin ) new_content = [ content ] if content . size () > 0 : if self . view . fold ( content ) == False : new_content = self . view . unfold ( content ) self . selection = new_content def plugin (): return FoldBrackets","title":"Run Instance Plugins"},{"location":"extended-regex/","text":"Extended Regex Guide Overview BH uses Python's Re regular expression engine, but it also adds some additional back references to aid in the creation of bracket patterns. This is done with a custom wrapper called Backrefs that was originally written for RegReplace . Backrefs was written to add various additional back references that are known to some regex engines, but not to Python's Re. Backrefs adds: \\p , \\P , \\u , \\U , \\l , \\L , \\Q or \\E (though \\u and \\U are replaced with \\c and \\C ). You can read more about Backrefs' features in Backrefs' documentation . Getting the Latest Backrefs It is not always clear when Package Control updates dependencies. So to force dependency updates, you can run Package Control's Satisfy Dependencies command which will update to the latest release. Using Backrefs in BracketHighlighter Plugins You can import Backrefs into a bh_plugin : from backrefs as bre Backrefs does provide a wrapper for all of Re's normal functions such as match , sub , etc., but it is recommended to pre-compile your search patterns and your replace patterns for the best performance; especially if you plan on reusing the same pattern multiple times. As Re does cache a certain amount of the non-compiled calls, you will be spared from some of the performance hit, but Backrefs does not cache the pre-processing of search and replace patterns. To use pre-compiled functions, you compile the search pattern with compile_search . If you want to take advantage of replace Backrefs, you need to compile the replace pattern as well. Notice the compiled pattern is fed into the replace pattern; you can feed the replace compiler the string representation of the search pattern as well, but the compiled pattern will be faster and is the recommended way. pattern = bre . compile_search ( r 'somepattern' , flags ) replace = bre . compile_replace ( pattern , r '\\1 some replace pattern' ) Then you can use the complied search pattern and replace text = pattern . sub ( replace , r 'sometext' ) or m = pattern . match ( r 'sometext' ) if m : text = replace ( m ) # similar to m.expand(template) To use the non-compiled search/replace functions, you call them just them as you would in Re; the names are the same. Methods like sub and subn will compile the replace pattern on the fly if given a string. for m in bre . finditer ( r 'somepattern' , 'some text' , bre . UNICODE | bre . DOTALL ): # do something If you want to replace without compiling, you can use the expand method. m = bre . match ( r 'sometext' ) if m : text = bre . expand ( m , r 'replace pattern' )","title":"Extended Regex Guide"},{"location":"extended-regex/#extended-regex-guide","text":"","title":"Extended Regex Guide"},{"location":"extended-regex/#overview","text":"BH uses Python's Re regular expression engine, but it also adds some additional back references to aid in the creation of bracket patterns. This is done with a custom wrapper called Backrefs that was originally written for RegReplace . Backrefs was written to add various additional back references that are known to some regex engines, but not to Python's Re. Backrefs adds: \\p , \\P , \\u , \\U , \\l , \\L , \\Q or \\E (though \\u and \\U are replaced with \\c and \\C ). You can read more about Backrefs' features in Backrefs' documentation .","title":"Overview"},{"location":"extended-regex/#getting-the-latest-backrefs","text":"It is not always clear when Package Control updates dependencies. So to force dependency updates, you can run Package Control's Satisfy Dependencies command which will update to the latest release.","title":"Getting the Latest Backrefs"},{"location":"extended-regex/#using-backrefs-in-brackethighlighter-plugins","text":"You can import Backrefs into a bh_plugin : from backrefs as bre Backrefs does provide a wrapper for all of Re's normal functions such as match , sub , etc., but it is recommended to pre-compile your search patterns and your replace patterns for the best performance; especially if you plan on reusing the same pattern multiple times. As Re does cache a certain amount of the non-compiled calls, you will be spared from some of the performance hit, but Backrefs does not cache the pre-processing of search and replace patterns. To use pre-compiled functions, you compile the search pattern with compile_search . If you want to take advantage of replace Backrefs, you need to compile the replace pattern as well. Notice the compiled pattern is fed into the replace pattern; you can feed the replace compiler the string representation of the search pattern as well, but the compiled pattern will be faster and is the recommended way. pattern = bre . compile_search ( r 'somepattern' , flags ) replace = bre . compile_replace ( pattern , r '\\1 some replace pattern' ) Then you can use the complied search pattern and replace text = pattern . sub ( replace , r 'sometext' ) or m = pattern . match ( r 'sometext' ) if m : text = replace ( m ) # similar to m.expand(template) To use the non-compiled search/replace functions, you call them just them as you would in Re; the names are the same. Methods like sub and subn will compile the replace pattern on the fly if given a string. for m in bre . finditer ( r 'somepattern' , 'some text' , bre . UNICODE | bre . DOTALL ): # do something If you want to replace without compiling, you can use the expand method. m = bre . match ( r 'sometext' ) if m : text = bre . expand ( m , r 'replace pattern' )","title":"Using Backrefs in BracketHighlighter Plugins"},{"location":"installation/","text":"Installation Package Control The recommended way to install BracketHighlighter is via Package Control . Package Control will install the correct branch on your system and keep it up to date. Ensure Package Control is installed. Instructions are found here . In Sublime Text, press Ctrl \uff0b Shift \uff0b P (Win, Linux) or Cmd \uff0b Shift \uff0b P (OSX) to bring up the quick panel and start typing Package Control: Install Package . Select the command and it will show a list of installable plugins. Start typing BracketHighlighter ; when you see it, select it. Restart to be sure everything is loaded proper. Enjoy! Manual Installation Warning This is not the recommended way to install BracketHighlighter for the average user. Installing this way will not get automatically updated. If you are forking for a pull request, you should just clone BH and run Package Control's Satisfy Dependency command to get all the dependencies. For those who want to install BH without package control, here are the steps. It is understood that some people, for what ever reason, will prefer manual install and may even have legitimate reasons to do so. When going this route, you will have to keep all the packages updated yourself. Download the latest releases of the following dependencies and unpack or git clone in the Packages folder as shown below: teddy_beer_maniac/sublime-text-dependency-markupsafe -> markupsafe teddy_beer_maniac/sublime-text-dependency-jinja2 -> python-jinja2 packagecontrol/pygments -> pygments facelessuser/sublime-markdown-popups -> mdpopups facelessuser/sublime-markdown -> python-markdown facelessuser/sublime-backrefs -> backrefs Download and unpack, or git clone, the latest BracketHighlighter release and unpack as BracketHighlighter : facelessuser/BracketHighlighter -> BracketHighlighter Create a folder under Packages called 00-dependencies and under that folder create a file called 00-dependencies.py : Copy the following code to 00-dependencies.py (this code was taken from Package Control): import sys import os from os.path import dirname if os . name == 'nt' : from ctypes import windll , create_unicode_buffer import sublime if sys . version_info >= ( 3 ,): def decode ( path ): return path def encode ( path ): return path if os . path . basename ( __file__ ) == 'sys_path.py' : pc_package_path = dirname ( dirname ( __file__ )) # When loaded as a .sublime-package file, the filename ends up being # Package Control.sublime-package/Package Control.package_control.sys_path else : pc_package_path = dirname ( __file__ ) st_version = u '3' else : def decode ( path ): if not isinstance ( path , unicode ): path = path . decode ( sys . getfilesystemencoding ()) return path def encode ( path ): if isinstance ( path , unicode ): path = path . encode ( sys . getfilesystemencoding ()) return path pc_package_path = decode ( os . getcwd ()) st_version = u '2' st_dir = dirname ( dirname ( pc_package_path )) def add ( path , first = False ): \"\"\" Adds an entry to the beginning of sys.path, working around the fact that Python 2.6 can't import from non-ASCII paths on Windows. :param path: A unicode string of a folder, zip file or sublime-package file to add to the path :param first: If the path should be added at the beginning \"\"\" if os . name == 'nt' : # Work around unicode path import issue on Windows with Python 2.6 buf = create_unicode_buffer ( 512 ) if windll . kernel32 . GetShortPathNameW ( path , buf , len ( buf )): path = buf . value enc_path = encode ( path ) if os . path . exists ( enc_path ): if first : try : sys . path . remove ( enc_path ) except ( ValueError ): pass sys . path . insert ( 0 , enc_path ) elif enc_path not in sys . path : sys . path . append ( enc_path ) def remove ( path ): \"\"\" Removes a path from sys.path if it is present :param path: A unicode string of a folder, zip file or sublime-package file \"\"\" try : sys . path . remove ( encode ( path )) except ( ValueError ): pass if os . name == 'nt' : buf = create_unicode_buffer ( 512 ) if windll . kernel32 . GetShortPathNameW ( path , buf , len ( buf )): path = buf . value try : sys . path . remove ( encode ( path )) except ( ValueError ): pass def generate_dependency_paths ( name ): \"\"\" Accepts a dependency name and generates a dict containing the three standard import paths that are valid for the current machine. :param name: A unicode string name of the dependency :return: A dict with the following keys: - 'ver' - 'plat' - 'arch' \"\"\" packages_dir = os . path . join ( st_dir , u 'Packages' ) dependency_dir = os . path . join ( packages_dir , name ) ver = u 'st %s ' % st_version plat = sublime . platform () arch = sublime . arch () return { 'all' : os . path . join ( dependency_dir , 'all' ), 'ver' : os . path . join ( dependency_dir , ver ), 'plat' : os . path . join ( dependency_dir , u ' %s _ %s ' % ( ver , plat )), 'arch' : os . path . join ( dependency_dir , u ' %s _ %s _ %s ' % ( ver , plat , arch )) } def add_dependency ( name , first = False ): \"\"\" Accepts a dependency name and automatically adds the appropriate path to sys.path, if the dependency has a path for the current platform and architecture. :param name: A unicode string name of the dependency :param first: If the path should be added to the beginning of the list \"\"\" dep_paths = generate_dependency_paths ( name ) for path in dep_paths . values (): if os . path . exists ( encode ( path )): add ( path , first = first ) add_dependency ( 'pygments' ) add_dependency ( 'backrefs' ) add_dependency ( 'markupsafe' ) add_dependency ( 'python-markdown' ) add_dependency ( 'python-jinja2' ) add_dependency ( 'mdpopups' ) Restart and enjoy. Git Cloning Quit Sublime Text. Open a terminal and enter the following. For dependencies, replace the URL with the appropriate URL, and the appropriate folder to check it out to: cd /path/to/Sublime Text 3/Packages git clone https://github.com/facelessuser/BracketHighlighter.git BracketHighlighter Restart Sublime Text.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#package-control","text":"The recommended way to install BracketHighlighter is via Package Control . Package Control will install the correct branch on your system and keep it up to date. Ensure Package Control is installed. Instructions are found here . In Sublime Text, press Ctrl \uff0b Shift \uff0b P (Win, Linux) or Cmd \uff0b Shift \uff0b P (OSX) to bring up the quick panel and start typing Package Control: Install Package . Select the command and it will show a list of installable plugins. Start typing BracketHighlighter ; when you see it, select it. Restart to be sure everything is loaded proper. Enjoy!","title":"Package Control"},{"location":"installation/#manual-installation","text":"Warning This is not the recommended way to install BracketHighlighter for the average user. Installing this way will not get automatically updated. If you are forking for a pull request, you should just clone BH and run Package Control's Satisfy Dependency command to get all the dependencies. For those who want to install BH without package control, here are the steps. It is understood that some people, for what ever reason, will prefer manual install and may even have legitimate reasons to do so. When going this route, you will have to keep all the packages updated yourself. Download the latest releases of the following dependencies and unpack or git clone in the Packages folder as shown below: teddy_beer_maniac/sublime-text-dependency-markupsafe -> markupsafe teddy_beer_maniac/sublime-text-dependency-jinja2 -> python-jinja2 packagecontrol/pygments -> pygments facelessuser/sublime-markdown-popups -> mdpopups facelessuser/sublime-markdown -> python-markdown facelessuser/sublime-backrefs -> backrefs Download and unpack, or git clone, the latest BracketHighlighter release and unpack as BracketHighlighter : facelessuser/BracketHighlighter -> BracketHighlighter Create a folder under Packages called 00-dependencies and under that folder create a file called 00-dependencies.py : Copy the following code to 00-dependencies.py (this code was taken from Package Control): import sys import os from os.path import dirname if os . name == 'nt' : from ctypes import windll , create_unicode_buffer import sublime if sys . version_info >= ( 3 ,): def decode ( path ): return path def encode ( path ): return path if os . path . basename ( __file__ ) == 'sys_path.py' : pc_package_path = dirname ( dirname ( __file__ )) # When loaded as a .sublime-package file, the filename ends up being # Package Control.sublime-package/Package Control.package_control.sys_path else : pc_package_path = dirname ( __file__ ) st_version = u '3' else : def decode ( path ): if not isinstance ( path , unicode ): path = path . decode ( sys . getfilesystemencoding ()) return path def encode ( path ): if isinstance ( path , unicode ): path = path . encode ( sys . getfilesystemencoding ()) return path pc_package_path = decode ( os . getcwd ()) st_version = u '2' st_dir = dirname ( dirname ( pc_package_path )) def add ( path , first = False ): \"\"\" Adds an entry to the beginning of sys.path, working around the fact that Python 2.6 can't import from non-ASCII paths on Windows. :param path: A unicode string of a folder, zip file or sublime-package file to add to the path :param first: If the path should be added at the beginning \"\"\" if os . name == 'nt' : # Work around unicode path import issue on Windows with Python 2.6 buf = create_unicode_buffer ( 512 ) if windll . kernel32 . GetShortPathNameW ( path , buf , len ( buf )): path = buf . value enc_path = encode ( path ) if os . path . exists ( enc_path ): if first : try : sys . path . remove ( enc_path ) except ( ValueError ): pass sys . path . insert ( 0 , enc_path ) elif enc_path not in sys . path : sys . path . append ( enc_path ) def remove ( path ): \"\"\" Removes a path from sys.path if it is present :param path: A unicode string of a folder, zip file or sublime-package file \"\"\" try : sys . path . remove ( encode ( path )) except ( ValueError ): pass if os . name == 'nt' : buf = create_unicode_buffer ( 512 ) if windll . kernel32 . GetShortPathNameW ( path , buf , len ( buf )): path = buf . value try : sys . path . remove ( encode ( path )) except ( ValueError ): pass def generate_dependency_paths ( name ): \"\"\" Accepts a dependency name and generates a dict containing the three standard import paths that are valid for the current machine. :param name: A unicode string name of the dependency :return: A dict with the following keys: - 'ver' - 'plat' - 'arch' \"\"\" packages_dir = os . path . join ( st_dir , u 'Packages' ) dependency_dir = os . path . join ( packages_dir , name ) ver = u 'st %s ' % st_version plat = sublime . platform () arch = sublime . arch () return { 'all' : os . path . join ( dependency_dir , 'all' ), 'ver' : os . path . join ( dependency_dir , ver ), 'plat' : os . path . join ( dependency_dir , u ' %s _ %s ' % ( ver , plat )), 'arch' : os . path . join ( dependency_dir , u ' %s _ %s _ %s ' % ( ver , plat , arch )) } def add_dependency ( name , first = False ): \"\"\" Accepts a dependency name and automatically adds the appropriate path to sys.path, if the dependency has a path for the current platform and architecture. :param name: A unicode string name of the dependency :param first: If the path should be added to the beginning of the list \"\"\" dep_paths = generate_dependency_paths ( name ) for path in dep_paths . values (): if os . path . exists ( encode ( path )): add ( path , first = first ) add_dependency ( 'pygments' ) add_dependency ( 'backrefs' ) add_dependency ( 'markupsafe' ) add_dependency ( 'python-markdown' ) add_dependency ( 'python-jinja2' ) add_dependency ( 'mdpopups' ) Restart and enjoy.","title":"Manual Installation"},{"location":"installation/#git-cloning","text":"Quit Sublime Text. Open a terminal and enter the following. For dependencies, replace the URL with the appropriate URL, and the appropriate folder to check it out to: cd /path/to/Sublime Text 3/Packages git clone https://github.com/facelessuser/BracketHighlighter.git BracketHighlighter Restart Sublime Text.","title":"Git Cloning"},{"location":"license/","text":"License Released under the MIT license. Copyright \u00a9 2013 - 2020 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"Released under the MIT license. Copyright \u00a9 2013 - 2020 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"usage/","text":"Basic Usage Overview Out of the box, BH will highlight brackets (or defined brackets like start and end blocks) surrounding the cursor. BH will also put opening and closing icons in the gutter of the corresponding line containing open or closing bracket. It is advised that you disable Sublime's default bracket and tag matcher in your Preferences.sublime-settings file or you will have matching conflicts: \"match_brackets\" : false , \"match_brackets_angle\" : false , \"match_brackets_braces\" : false , \"match_brackets_content\" : false , \"match_brackets_square\" : false , \"match_tags\" : false If you are using Sublime Text build 3124+, a new feature has been added which shows a popup when you mouse over a bracket that has its matching bracket pair off screen. It will show where the other bracket is located with line context and provide a link to jump to the other bracket. When mousing over a bracket in which the match could not be found, a popup explaining why this might occur will be shown and give the option to click a link which will perform a search without thresholds to see if it can find the brackets when restraints are removed. Built-in Supported brackets BH supports a variety of brackets out of the box; here are some examples: round square curly angle single and double quotes Python single, double, and triple quotes (Unicode and raw) Django Python templates with mixed HTML, CSS, and JavaScript JavaScript regex Perl regex Ruby regex Markdown bold, italic, and code blocks CSSedit groups Ruby conditional statements C/C++ compiler switches PHP conditional keywords PHP angle brackets <?php ?> Erlang conditional statements HTML, ColdFusion, XML, and various other template tags Bash conditional and looping constructs Fish conditional and looping constructs Lua Pascal Elixir Within supported regex and strings, BH can also highlight basic sub brackets between the matched quotes: (), [], {} . General Commands BH has a couple of additional features built-in which are found in the command palette. Toggle Global Enable The bh_toggle_enable command enables and disables BH globally. Toggle String Bracket Escape Mode bh_toggle_string_escape_mode toggles BH 's recognition mode of escaped sub brackets in strings and regex. The modes are string escape mode and regex escape mode. Find Matching Offscreen Brackets When show_offscreen_bracket_popup is enabled, mousing over an on screen bracket, or invoking the bh_offscreen_popup command, will show a popup on the screen that reveals the location of the matching offscreen bracket(s) (only available for Sublime Text 3 versions that support this). The cursor needs to be between a matching pair of brackets. Bracket Plugin Commands BH is also extendable via plugins and provides a number of built-in Bracket Plugins that take advantage of BH 's matching to provide additional features. Most plugin features are available via the command palette. To see how to configure shortcuts, see the Example.sublime-keymap file. Bracket Select Plugin The Bracket Select plugin selects the content between the brackets or moves the selection to the opening or closing bracket. Behavior is slightly modified for tags. Swap Brackets Plugin The Swap Brackets plugin can swap the current brackets to another type of bracket. When selected, it will displays the bracket options that are allowed for the current language. Allowed brackets are defined in bh_swapping.sublime-settings . Wrap Brackets Plugin The Wrap Brackets plugin wraps selected text with a bracket pair. When selected, it will display the bracket options that are allowed for the current language. Allowed brackets are defined in bh_wrapping.sublime-settings . Bracket Remove Plugin The Bracket Remove plugin removes the surrounding brackets around the cursor. Fold Bracket Plugin The Fold Bracket plugin folds the content of the current surrounding brackets. Swap Quotes Plugin The Swaps Quotes plugin swaps the quote style of surrounding quotes from double to single or vice versa. It also handles escaping and un-escaping of sub quotes. Tag Plugin The Tag plugin Provides extra logic to target and highlight XML/HTML tags. To use BH 's built-in HTML highlighting in your HTML-like template language of choice, add it to the list in bh_tag.sublime_settings . Tag Attribute Select Plugin The Tag Attribute plugin can cycle through the tag attributes of the selected tag. Tag Name Select Plugin Tag Name Select plugin selects the opening and closing tag name of the current selected tag. Keyboard Shortcuts BH provides no keyboard shortcuts in order to avoid shortcut conflicts, but you can view the included Example.sublime-keymap file to get an idea how to set up your own.","title":"Basic Usage"},{"location":"usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"usage/#overview","text":"Out of the box, BH will highlight brackets (or defined brackets like start and end blocks) surrounding the cursor. BH will also put opening and closing icons in the gutter of the corresponding line containing open or closing bracket. It is advised that you disable Sublime's default bracket and tag matcher in your Preferences.sublime-settings file or you will have matching conflicts: \"match_brackets\" : false , \"match_brackets_angle\" : false , \"match_brackets_braces\" : false , \"match_brackets_content\" : false , \"match_brackets_square\" : false , \"match_tags\" : false If you are using Sublime Text build 3124+, a new feature has been added which shows a popup when you mouse over a bracket that has its matching bracket pair off screen. It will show where the other bracket is located with line context and provide a link to jump to the other bracket. When mousing over a bracket in which the match could not be found, a popup explaining why this might occur will be shown and give the option to click a link which will perform a search without thresholds to see if it can find the brackets when restraints are removed.","title":"Overview"},{"location":"usage/#built-in-supported-brackets","text":"BH supports a variety of brackets out of the box; here are some examples: round square curly angle single and double quotes Python single, double, and triple quotes (Unicode and raw) Django Python templates with mixed HTML, CSS, and JavaScript JavaScript regex Perl regex Ruby regex Markdown bold, italic, and code blocks CSSedit groups Ruby conditional statements C/C++ compiler switches PHP conditional keywords PHP angle brackets <?php ?> Erlang conditional statements HTML, ColdFusion, XML, and various other template tags Bash conditional and looping constructs Fish conditional and looping constructs Lua Pascal Elixir Within supported regex and strings, BH can also highlight basic sub brackets between the matched quotes: (), [], {} .","title":"Built-in Supported brackets"},{"location":"usage/#general-commands","text":"BH has a couple of additional features built-in which are found in the command palette.","title":"General Commands"},{"location":"usage/#toggle-global-enable","text":"The bh_toggle_enable command enables and disables BH globally.","title":"Toggle Global Enable"},{"location":"usage/#toggle-string-bracket-escape-mode","text":"bh_toggle_string_escape_mode toggles BH 's recognition mode of escaped sub brackets in strings and regex. The modes are string escape mode and regex escape mode.","title":"Toggle String Bracket Escape Mode"},{"location":"usage/#find-matching-offscreen-brackets","text":"When show_offscreen_bracket_popup is enabled, mousing over an on screen bracket, or invoking the bh_offscreen_popup command, will show a popup on the screen that reveals the location of the matching offscreen bracket(s) (only available for Sublime Text 3 versions that support this). The cursor needs to be between a matching pair of brackets.","title":"Find Matching Offscreen Brackets"},{"location":"usage/#bracket-plugin-commands","text":"BH is also extendable via plugins and provides a number of built-in Bracket Plugins that take advantage of BH 's matching to provide additional features. Most plugin features are available via the command palette. To see how to configure shortcuts, see the Example.sublime-keymap file.","title":"Bracket Plugin Commands"},{"location":"usage/#bracket-select-plugin","text":"The Bracket Select plugin selects the content between the brackets or moves the selection to the opening or closing bracket. Behavior is slightly modified for tags.","title":"Bracket Select Plugin"},{"location":"usage/#swap-brackets-plugin","text":"The Swap Brackets plugin can swap the current brackets to another type of bracket. When selected, it will displays the bracket options that are allowed for the current language. Allowed brackets are defined in bh_swapping.sublime-settings .","title":"Swap Brackets Plugin"},{"location":"usage/#wrap-brackets-plugin","text":"The Wrap Brackets plugin wraps selected text with a bracket pair. When selected, it will display the bracket options that are allowed for the current language. Allowed brackets are defined in bh_wrapping.sublime-settings .","title":"Wrap Brackets Plugin"},{"location":"usage/#bracket-remove-plugin","text":"The Bracket Remove plugin removes the surrounding brackets around the cursor.","title":"Bracket Remove Plugin"},{"location":"usage/#fold-bracket-plugin","text":"The Fold Bracket plugin folds the content of the current surrounding brackets.","title":"Fold Bracket Plugin"},{"location":"usage/#swap-quotes-plugin","text":"The Swaps Quotes plugin swaps the quote style of surrounding quotes from double to single or vice versa. It also handles escaping and un-escaping of sub quotes.","title":"Swap Quotes Plugin"},{"location":"usage/#tag-plugin","text":"The Tag plugin Provides extra logic to target and highlight XML/HTML tags. To use BH 's built-in HTML highlighting in your HTML-like template language of choice, add it to the list in bh_tag.sublime_settings .","title":"Tag Plugin"},{"location":"usage/#tag-attribute-select-plugin","text":"The Tag Attribute plugin can cycle through the tag attributes of the selected tag.","title":"Tag Attribute Select Plugin"},{"location":"usage/#tag-name-select-plugin","text":"Tag Name Select plugin selects the opening and closing tag name of the current selected tag.","title":"Tag Name Select Plugin"},{"location":"usage/#keyboard-shortcuts","text":"BH provides no keyboard shortcuts in order to avoid shortcut conflicts, but you can view the included Example.sublime-keymap file to get an idea how to set up your own.","title":"Keyboard Shortcuts"},{"location":"_snippets/abbr/","text":"","title":"Abbr"},{"location":"_snippets/links/","text":"","title":"Links"},{"location":"_snippets/refs/","text":"","title":"Refs"}]}